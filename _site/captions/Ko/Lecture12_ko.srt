1
00:00:00,000 --> 00:00:02,990
 오늘 우리는이 네 개의 주요 소프트웨어 패키지를 통해 갈거야 그 사람들 

2
00:00:02,990 --> 00:00:10,919
 일반적으로 보통 몇 관리자 가지 이정표로 사용 

3
00:00:10,919 --> 00:00:14,798
 실제로 그렇게 희망을 살펴하려고합니다 남자를 반환 지난 주 않는 한 

4
00:00:14,798 --> 00:00:19,089
 최종 할당은 3 사람들에 이번 주 또한 할당을 기억 

5
00:00:19,089 --> 00:00:23,160
 거야 그래서 수요일에 기인하고 너희들은 아직 

6
00:00:23,160 --> 00:00:30,870
 확인 그건 그 다음 당신은 당신이 잘 늦게 일을해야했습니다 좋은 

7
00:00:30,870 --> 00:00:34,230
 내가 지적해야 다른 또 다른 한가지는 당신이 실제로 있다면 

8
00:00:34,229 --> 00:00:37,619
 내가 당신을 많이 생각 프로젝트에 대한 터미널을 사용할 계획 

9
00:00:37,619 --> 00:00:42,049
 당신은 당신이 떨어져 코드 및 데이터 물건을 백업하고 있는지 확인 

10
00:00:42,049 --> 00:00:46,659
 아버지의 경우는 가끔씩 우리는 어떤 데 문제 했어 

11
00:00:46,659 --> 00:00:50,529
 인스턴스는 무작위로 충돌하고 대부분의 경우 단말기 사람들은왔다 

12
00:00:50,530 --> 00:00:53,989
 데이터를 다시 얻을 수 있지만 때로는 몇 일이 소요 및 

13
00:00:53,988 --> 00:00:57,570
 이 때문에 사람들이 손실 된 데이터를 실제 사례 몇 가지가있었습니다 

14
00:00:57,570 --> 00:01:01,558
 그냥 터미널에 그 당신이 사용하려는 경우 내가 생각하는 그래서 추락 

15
00:01:01,558 --> 00:01:04,569
 단말기는 당신이 어떤 다른 백업 전략을 가지고 있는지 확인 

16
00:01:04,569 --> 00:01:10,250
 코드와 나는 같은 데이터는 우리가이 불쌍한 대해 얘기 밝혔다 

17
00:01:10,250 --> 00:01:16,049
 일반적으로 깊은 학습 카페 토치 피아노에 사용되는 소프트웨어 패키지와 

18
00:01:16,049 --> 00:01:20,269
 텐서 흐름과 내가 같은 느낌이 처음에 부인의 조금으로 

19
00:01:20,269 --> 00:01:24,179
 개인적으로 나는 주로 내가 아는 그 사람 때문에 카페와 성화와 함께 일했습니다 

20
00:01:24,180 --> 00:01:27,710
 I에 대한 가장 당신에게 다른 사람에 대한 좋은 맛을뿐만 아니라 제공하기 위해 최선을 다하겠습니다 

21
00:01:27,709 --> 00:01:35,939
 하지만 단지 첫 번째, 그래서 거기에 그 부인을 던지는 것은 우리가 본 카페입니다 

22
00:01:35,939 --> 00:01:39,509
 정말 카페이었다 버클리에서 본 논문에서 튀어 마지막 강의 

23
00:01:39,510 --> 00:01:44,040
 재 고용 알렉스 NAT와 알렉스하려고하는 것은 다른 것들과 이후 기능 

24
00:01:44,040 --> 00:01:47,550
 다음 캐시는 정말 널리 사용되는 정말 인기로 성장했다 

25
00:01:47,549 --> 00:01:53,759
 카페 버클리에서 그래서 특히 길쌈 신경망을위한 패키지 

26
00:01:53,760 --> 00:01:56,859
 난 당신이 많은 사람들은 더없는이 생각 

27
00:01:56,859 --> 00:02:01,989
 그것은 대부분 C ++로 작성 실제로 카페에 대한 일이 구입되어, 

28
00:02:01,989 --> 00:02:04,939
 당신은 매우 유용하다 matlab에 파이썬에서 그물과 이것 저것에 액세스 할 수 있습니다 

29
00:02:04,939 --> 00:02:09,969
 일반 카페에서 정말 널리 사용하고 그냥 경우는 정말 정말 좋은 

30
00:02:09,969 --> 00:02:15,289
 일종의 표준 피드 포워드 컨볼 루션 네트워크를 훈련하고 싶은 

31
00:02:15,289 --> 00:02:17,489
 실제로 카페는 다른 사람보다 약간 다르다 

32
00:02:17,490 --> 00:02:21,610
 이 점에서 다른 프레임 워크는 당신이 실제로 큰 강력한 모델을 훈련하고 

33
00:02:21,610 --> 00:02:26,150
 예제 ResNet 이미지를 그래서 어떤 코드를 직접 작성하지 않고 유지 

34
00:02:26,150 --> 00:02:29,760
 분류 모델을 하나의 이미지 하나 다 작년에 당신이 할 수있는 그 

35
00:02:29,759 --> 00:02:33,189
 실제로 꽤 임의의 코드를 작성하지 않고 카페를 사용하여 공진 훈련 

36
00:02:33,189 --> 00:02:37,579
 놀라운 가장 그러나 당신이 작업하는 가장 중요한 팁 그래서 

37
00:02:37,580 --> 00:02:41,860
 카페 설명서를 항상 최신 상태로 때때로되지 않고하지 않는 것이있다 

38
00:02:41,860 --> 00:02:45,980
 완벽한 그래서 당신은 단지 거기에 다이빙 소스를 읽을 두려워하지 필요 

39
00:02:45,979 --> 00:02:52,359
 그것은 ++ C의 너무 잘하면 당신이 그것을 읽고 이해 만에 할 수 있습니다 자신을 코드 

40
00:02:52,360 --> 00:02:56,080
 그들이 인터페이스가 일반 C ++ 코드를 꽤 잘 구성되어 

41
00:02:56,080 --> 00:03:00,270
 꽤 잘 조직하고 대한 의심이있는 경우 아주 쉽게 그렇게 이해하기 

42
00:03:00,270 --> 00:03:04,459
 일이 카페에서 일하는 당신은 어떻게 당신의 가장 좋은 건에 가서 일어나서을 읽을 그냥 할 

43
00:03:04,459 --> 00:03:11,229
 카페 그래서 소스 코드는 아마 수천 마이크와 함께이 거대한 큰 프로젝트입니다 

44
00:03:11,229 --> 00:03:14,369
 수십 줄의 코드 수천하고 이해하기 무서운 약간의 

45
00:03:14,370 --> 00:03:18,730
 모든 것을 함께 맞는하지만 카페에서 정말 네 개의 주요 클래스를 거기에 어떻게 

46
00:03:18,729 --> 00:03:24,310
 첫 번째 일에 대해 알 필요가있는 얼룩 때문에 모든 군대 저장소를 모양 당신의 

47
00:03:24,310 --> 00:03:27,939
 데이터와 무게와 네트워크에서 활성화 그래서 이러한 

48
00:03:27,939 --> 00:03:34,870
 모양은 그래서 당신의 무게가 차단 한있는 네트워크의 것들 당신의 비율은 

49
00:03:34,870 --> 00:03:38,680
 블롭에 저장되어있는 데이터는 픽셀 값처럼 될 것이다있다 

50
00:03:38,680 --> 00:03:43,189
 블롭에 저장 레이블 당신의 아내 또는 BLOB에 저장된 모든의 

51
00:03:43,189 --> 00:03:47,319
 모양이입니다 귀하의 중간 정품 인증은 모양에 저장됩니다 

52
00:03:47,319 --> 00:03:51,069
 과 차원 텐서는 일종의 당신이 본 것 같은 심판은 허용 

53
00:03:51,069 --> 00:03:56,150
 그들이 가진 내부 실제로 무 차원 tenser 네 사본을 

54
00:03:56,150 --> 00:03:57,370
 데이터 

55
00:03:57,370 --> 00:04:02,450
 실제 원시 데이터하고 저장하는 텐서의 데이터 버전 

56
00:04:02,449 --> 00:04:07,449
 또한 카페가 사용하는 병렬 일을 가지고 있지만 10 평행 죽음을 원 

57
00:04:07,449 --> 00:04:12,459
 저장소는 데이터에 대한 그라디언트 그것은 당신에게 당신에게 두 가지를 제공하고 

58
00:04:12,459 --> 00:04:16,280
 그런 것들의 각각의 CPU와 GPU 버전이 있기 때문에 실제로 사를 

59
00:04:16,279 --> 00:04:21,228
 그래서 당신은 CPU의 데이터 유형이 있고 GPU 실제로 사 및 치수있다 

60
00:04:21,228 --> 00:04:26,159
 텐트 당신이 알아야 할 그 다음 중요한 클래스 로브 뛰어난이며, 

61
00:04:26,160 --> 00:04:30,930
 은신처를 카페와 래리는 것과 유사한에서 함수의 일종이다 사람 

62
00:04:30,930 --> 00:04:35,329
 일부 입력 모양을받는 특징에 글을 입력 바닥을 야유 

63
00:04:35,329 --> 00:04:41,269
 다음 구멍 정지를 유지 출력 모양을 생각한다는 것입니다 LOB를 생성하여 

64
00:04:41,269 --> 00:04:45,349
 은신처가 채워 데이터 (RD)와 바닥 모양에 포인터를 받게되며 

65
00:04:45,350 --> 00:04:49,229
 다음은 상단 모양에 대한 포인터를 받게됩니다 그리고 포트에 겁니다 

66
00:04:49,228 --> 00:04:53,759
 열정적으로 상위의 데이터 요소의 값을 입력 할 것으로 예상 

67
00:04:53,759 --> 00:04:58,959
 층을지나 다시 도로에 블로그 래디언스 검은 담비가 기대 계산합니다 

68
00:04:58,959 --> 00:05:03,649
 기울기와 상부 작업에 대한 포인터를 수신하고 활성화 쏟 

69
00:05:03,649 --> 00:05:07,359
 를 사용하며 그들은 또한 바닥 모양에 대한 포인터까지를 받게됩니다 

70
00:05:07,360 --> 00:05:12,650
 재료 바닥과 블레어 총리는이 추상 꽤 잘 구성되어 

71
00:05:12,649 --> 00:05:17,019
 클래스 당신은 갈 수 있고 내가 여기에 소스 파일에 대한 링크를했다 그 

72
00:05:17,019 --> 00:05:21,139
 그리고 그들의의 다른 유형을 구현하는 몇 가지 클래스가 많이있다 및 

73
00:05:21,139 --> 00:05:26,750
 같은 나는 일반적인 캡이 문제가 모든 전혀 정말 좋은 목록이 없습니다 말했다 

74
00:05:26,750 --> 00:05:30,490
 유형의 은신처 당신은 거의 그냥 코드를보고 어떤 종류를 볼 필요가 

75
00:05:30,490 --> 00:05:36,280
 CPP 파일은 자연 있도록 당신이 알아야 할 다음 일은있다 

76
00:05:36,279 --> 00:05:40,859
 그것은 단지 다수의 상속인을 결합하고는 기본적으로 비순환 그래프에 관한 것이다 

77
00:05:40,860 --> 00:05:44,598
 층과하면의 전후 방법을 실행하기위한 책임 

78
00:05:44,598 --> 00:05:49,519
 올바른 순서 층은 그래서 이것은 당신은 아마이 터치하지 않아도된다 

79
00:05:49,519 --> 00:05:52,560
 자신 만이에 가지 좋은 볼의 어느 클래스는 방법의 맛을 얻을 수 

80
00:05:52,560 --> 00:05:56,139
 모든 당신이 알아야 할 마지막 클래스에서 함께 맞는 

81
00:05:56,139 --> 00:06:00,720
 솔버가 솔버 있도록 우리가 숙제 해결사이라는 것을 알고 

82
00:06:00,720 --> 00:06:04,710
 그 정말 재주 넘기를 캡에서 영감을받은 나에 찍어하기위한 것입니다 

83
00:06:04,709 --> 00:06:05,288
 순 

84
00:06:05,288 --> 00:06:08,889
 실제로 업데이트 데이터의 다음 전후 실행할 

85
00:06:08,889 --> 00:06:11,319
 네트워크와 핸들 검사 점과에서 다시 시작의 소유자 

86
00:06:11,319 --> 00:06:15,520
 체크 포인트 및 물건의 카페 해결사의 모든 종류의이 추상입니다 

87
00:06:15,519 --> 00:06:20,278
 클래스와 다른 갱신 규칙은 다른 서브 클래스에 의해 구현된다 그래서 

88
00:06:20,278 --> 00:06:24,598
 예를 확률 그라데이션 하강을 위해 존재하는 것은 해석 원자 폭탄 엉덩이있다 

89
00:06:24,598 --> 00:06:28,209
 문제 해결사 다시 물건의 종류의 모든과는 어떤 종류를 볼 수 있습니다 

90
00:06:28,209 --> 00:06:32,438
 옵션을 제공합니다 당신은 이런 종류의 소스 코드를 찾아야한다 사용할 수 있습니다 

91
00:06:32,439 --> 00:06:35,639
 당신이 일 모두가이 모든 일이 있음을 함께 맞는 방법의 좋은 개요 

92
00:06:35,639 --> 00:06:40,069
 인터넷에서 할 것이다 오른쪽 녹색 상자에 포함 각을 얼룩 

93
00:06:40,069 --> 00:06:44,250
 블로그는 데이터를 포함하고 빨간색 상자가 연결되어있는 층이다 텍스트 

94
00:06:44,250 --> 00:06:51,038
 함께 블록과 모든 일이 시편에 최적화 얻을 것이다 그래서 

95
00:06:51,038 --> 00:06:55,538
 카페 프로토콜이라는 재미있는 것은 많이 사용 너희들의 버퍼 수 

96
00:06:55,538 --> 00:07:00,938
 이제까지 숫자 후 구글에 다시 너희들은이 폭탄 그러나 프로토콜에 대해 알고 

97
00:07:00,939 --> 00:07:05,099
 권총은 거의 이진 강하게 나는 종류의에 같은 JSON을 입력처럼 이쪽 

98
00:07:05,098 --> 00:07:08,550
 구글이 처음에 데이터를 이용하여 내부에 매우 널리 사용되는 그것에 대해 생각 

99
00:07:08,550 --> 00:07:14,750
 네트워크를 통해 죽음은 그래서 프로토콜이있다 버퍼링한다. 그 프로필 

100
00:07:14,750 --> 00:07:18,639
 서로 다른 객체의 형태를 어떻게 그렇게 느낌의 종류를 정의 

101
00:07:18,639 --> 00:07:22,819
 이 예에서 사용자는 이름 및 ID 및 이메일이 생명을 가지고있을 것 

102
00:07:22,819 --> 00:07:26,300
 최고의 프로필입니다. 프로필 

103
00:07:26,300 --> 00:07:31,490
 클래스의 유형을 찾기 위해 주어진 당신은 실제로에 인스턴스를 실현 볼 수 있습니다 

104
00:07:31,490 --> 00:07:37,379
 사람이 읽을. 예를 들어 이것은주는 이름 총 TXT 파일을 채우고 있으므로 

105
00:07:37,379 --> 00:07:40,968
 당신은 아이디어가 당신에게 이메일을 제공하고이 사람의 인스턴스입니다 수 

106
00:07:40,968 --> 00:07:45,930
 이 텍스트 파일로 저장 한 후 제품이 컴파일러를 포함 

107
00:07:45,930 --> 00:07:49,579
 실제로 액세스 다양한 프로그래밍 언어에서 클래스를 생성 할 수 있습니다 

108
00:07:49,579 --> 00:07:55,418
 당신이 할 수있는 이러한 데이터 형식 포토 북 컴파일러를 실행 한 후이 그것을 프로필 

109
00:07:55,418 --> 00:08:01,038
 당신은 자바와 C C에 가져 ++과 파이썬과 갈 수있는 클래스를 생성 

110
00:08:01,038 --> 00:08:05,300
 모든 그래서 실제로 카페가 있습니다 단지에 대해 왜 이러한 프로브를 말합니까 

111
00:08:05,300 --> 00:08:08,270
 이러한 프로토콜 버퍼 그들은 거의 모든 것을 저장을 사용하여 

112
00:08:08,269 --> 00:08:16,008
 캐시는 내가 말했듯 있도록 카페를 이해하는 코드를 읽을 필요가 이해하기 

113
00:08:16,009 --> 00:08:20,480
 카페이 하나의 거대한 파일이라는 카페 어두운 도로가 

114
00:08:20,480 --> 00:08:24,470
 그들은 단지에서 사용되는 프로토콜 버퍼 유형 모두를 정의하지만 

115
00:08:24,470 --> 00:08:29,170
 카페는이 나는 그것이 몇 생각의 거대한 파일 만 라인 긴하지만 

116
00:08:29,170 --> 00:08:32,200
 실제로 꽤 잘 문서화 그리고 내가 가장 최신의 생각입니다 

117
00:08:32,200 --> 00:08:35,890
 은신처 유형이 무엇인지의 문서는 어떤 이들 계층에 대한 옵션입니다 

118
00:08:35,889 --> 00:08:39,629
 당신이 솔버 및 레이어와마다 모든 옵션을 지정하는 방법입니다 

119
00:08:39,629 --> 00:08:43,100
 그 때문에 난 정말이 파일을 체크 아웃하고 읽어 보시기 바랍니다 모든 나쁘지 않다 

120
00:08:43,100 --> 00:08:48,019
 일이 카페 단지 어떻게 작동하는지 그것을 통해 당신에 대한 질문이있는 경우 

121
00:08:48,019 --> 00:08:53,120
 이 매개 변수보다 정의이 당신을 보여줍니다 당신이 내 왼쪽 귀에서 맛을 제공 

122
00:08:53,120 --> 00:08:58,519
 이는 카페 도끼를 나타내는 데 사용 프로토콜 버퍼의 종류 및 

123
00:08:58,519 --> 00:09:03,970
 오른쪽 해법을 나타내는 데,이 해석 파라미터 있도록 

124
00:09:03,970 --> 00:09:09,009
 예를 들어 솔버 프로모터의 경계가 그물에 대한 참조를 취하고 

125
00:09:09,009 --> 00:09:12,409
 또한 학습 속도와 빈도 점을 확인하는 방법과 같은 것들을 포함 

126
00:09:12,409 --> 00:09:19,549
 당신이 카페에서 작업 할 때 바로 그래서 실제로 있다는 같은 다른 것들 

127
00:09:19,549 --> 00:09:23,729
 정말 멋진 그렇게 할 때 모델을 양성하기 위해 코드를 작성할 필요가 없습니다 

128
00:09:23,730 --> 00:09:27,889
 카페 작업 당신은 일반적으로 당신은 그래서 먼저이 4 단계 프로세스를 

129
00:09:27,889 --> 00:09:31,960
 데이터를 변환하고 그냥 이미지 분류 문제가 발생할 경우 특히 

130
00:09:31,960 --> 00:09:34,540
 당신은 단지 기존 중 하나를 사용이를 위해 당신은 어떤 코드를 작성할 필요가 없습니다 

131
00:09:34,539 --> 00:09:40,240
 다니엘 이진 카파 배는 방금로 할 것이다 당신의 파일을 정의 

132
00:09:40,240 --> 00:09:45,230
 작성 또는 편집이 단백질 다니엘 중 하나는 다시 해석을 정의 

133
00:09:45,230 --> 00:09:49,509
 단지 프로보 TXT TXT 파일에 살 것이다 당신은 텍스트 내에서 작동 할 수 

134
00:09:49,509 --> 00:09:54,200
 편집기 다음은 훈련이 기존 바이너리에이 일을 모두 통과합니다 

135
00:09:54,200 --> 00:09:57,990
 모델과 전투는 기차가 그 다음에 할 수 있는지 테스트하는 모델을 계속 뱉어 

136
00:09:57,990 --> 00:10:02,820
 당신은 당신이 할 수 이미지에 ResNet 훈련을 할 경우에도, 그래서 다른 것들에 사용 

137
00:10:02,820 --> 00:10:06,000
 그냥 간단한 절차를 따르 쓰기없이 거대한 네트워크를 훈련 

138
00:10:06,000 --> 00:10:12,110
 정말 멋진 등 만 데이터를 변환하기 위해 일반적으로 한 단계 코드 

139
00:10:12,110 --> 00:10:17,259
 그래서 카페 나는 우리가 형식으로 HTML5에 대해 조금 얘기했습니다 알고 사용 

140
00:10:17,259 --> 00:10:21,460
 지속적으로 책상에 픽셀을 저장하고 효율적으로 읽는하지만, 

141
00:10:21,460 --> 00:10:26,940
 경우가 물었다 그래서 기본적으로 캐시는 LM TV라는이 다른 파일 형식을 사용 

142
00:10:26,940 --> 00:10:30,570
 당신이 당신이 가진 모든 레이블이 각 이미지 다음 이미지의 무리 인 경우 당신은 할 수 

143
00:10:30,570 --> 00:10:31,480
 롤 호출 

144
00:10:31,480 --> 00:10:35,370
 카페는 수 거대한 alamoudi에 그 전체 데이터 집합을 변환하는 스크립트가 있습니다 

145
00:10:35,370 --> 00:10:42,169
 젠은 당신에게 방법의 아이디어를 제공 할 수 있도록이는 그것의 훈련을 위해 사용할 수 있습니다 

146
00:10:42,169 --> 00:10:46,240
 당신은 당신의 이미지에 대한 경로를 가진 텍스트 파일을 작성 정말 쉽고 

147
00:10:46,240 --> 00:10:49,959
 라벨로 구분하고 그냥 승객은 스크립트가 몇 기다려 유지 

148
00:10:49,958 --> 00:10:56,018
 시간 데이터가 디스크에 큰 거대한 IMDB 파일을 설정하고있는 경우에는 작업하는 경우 

149
00:10:56,019 --> 00:11:01,860
 HBO 오 같은 뭔가 다른 당신은 아마 카페 그래서 자신을 만들어야합니다 

150
00:11:01,860 --> 00:11:06,060
 실제로 데이터를 읽는 몇 가지 옵션을 가지고이 날짜에있다 않습니다 

151
00:11:06,059 --> 00:11:11,888
 자신의 윈도우 다토 보호를위한 시장 실제로는 HDL 5에서 읽을 수 있습니다 

152
00:11:11,889 --> 00:11:14,350
 특히의 직접 메모리에서 읽기 물건에 대한 옵션이있다 

153
00:11:14,350 --> 00:11:18,480
 이 모든 파이썬 인터페이스하지만 내 관점에서 적어도 유용 

154
00:11:18,480 --> 00:11:22,339
 캠페인에 읽기 및 데이터의 다른 방법의 종류가 조금 있습니다 

155
00:11:22,339 --> 00:11:26,120
 두 번째 수준의 카페 생태계에서 시민과 엘렌 DBA 정말입니다 

156
00:11:26,120 --> 00:11:30,669
 가장 쉬운 것은 당신이 당신이 아마 변환을 시도해야 할 수 있습니다 그래서 만약 작동하는 방법 

157
00:11:30,669 --> 00:11:40,179
 그래서 24 캠페인 단계와 mp3 형식으로 데이터가 있으므로 객체를 정의하는 것입니다 

158
00:11:40,179 --> 00:11:44,609
 같은 나는 그가 그냥하지 그래서 여기에이를 찾기 위해 큰 프로모션 TXT를 작성하는 것입니다 말했다 

159
00:11:44,610 --> 00:11:48,818
 로지스틱 회귀 분석이 단순한 모델 당신은 내가하지 않았다 것을 알 수있다 

160
00:11:48,818 --> 00:11:53,948
 내 자신의 조언을 따라 난 다음 여기에 HDL (5) 파일에서 데이터를 읽고 있어요 

161
00:11:53,948 --> 00:11:59,278
 내적 및 캐세이보다라고 완전히 연결 층을 

162
00:11:59,278 --> 00:12:03,588
 완전히 은신처를 연결되어 자신의 권리는 당신에게 수업 방법의 수를 알려줍니다 

163
00:12:03,589 --> 00:12:10,399
 값을 초기화하고 내가 읽어 부드러운 최대 손실 함수를합니다 

164
00:12:10,399 --> 00:12:15,458
 라벨과는 반대 선출 된 리더에서 손실 성분을 생성하므로 

165
00:12:15,458 --> 00:12:20,009
 이 파일에 대해 지적하는 몇 가지 있습니다 일반적으로 한 모든 층이 

166
00:12:20,009 --> 00:12:23,588
 가중치의 데이터를 저장하기 위해 약간의 블로그와 기울기를 포함 

167
00:12:23,589 --> 00:12:28,680
 그리고 층의 모양과 벨레 자체가 일반적으로 할 수있는 같은 이름을 가진 

168
00:12:28,679 --> 00:12:34,269
 다른 일을 혼란 조금 이들 층의 많은이있을 것입니다 

169
00:12:34,269 --> 00:12:39,250
 바로 당신이거야 여기에이 네트워크에 실제로 14 무게 14 바이어스와 모양 

170
00:12:39,250 --> 00:12:43,149
 즉 학습 속도가 그래서 그 두 모양의 학습 속도를 찾아 

171
00:12:43,149 --> 00:12:44,769
 방법 모두 정규화 

172
00:12:44,769 --> 00:12:50,198
 참고로 나중에 또 하나의 바이어스는 출력의 수를 지정하는 것입니다 

173
00:12:50,198 --> 00:12:51,568
 클래스는 단지 숫자입니다 

174
00:12:51,568 --> 00:12:57,378
 이 완전히 연결 은신처 주변에 출력하고 마지막으로 신속하고 

175
00:12:57,379 --> 00:13:01,139
 레이어와 카페를 동결 더러운 방법은 학습 속도 (204)를 설정하는 것입니다 

176
00:13:01,139 --> 00:13:08,048
 그런 식으로 연결된 모양에 대한 우리의 편견 지적하는 또 다른 일이 

177
00:13:08,048 --> 00:13:12,600
 밖으로 구글과 같은 ResNet 및 기타 대형 모델이 얻을 수 있다는 것입니다 

178
00:13:12,600 --> 00:13:17,110
 정말 정말 빨리 손에서 카페 정말 당신처럼 정의 할 수 없습니다 있도록 

179
00:13:17,110 --> 00:13:20,989
 조성의 ality ResNet을 위해 그들은 단지 동일한 패턴을 통해 반복되도록 

180
00:13:20,989 --> 00:13:26,459
 반복해서 ResNet의 프로토 TXT 그래서 프로 txt 파일에 거의 7,000 선이다 

181
00:13:26,458 --> 00:13:31,219
 당신이 손으로 그것을 쓸 수 있지만 중간 연습 사람들이 쓰는 경향이 긴 있도록 

182
00:13:31,220 --> 00:13:35,470
 그가가의 그래서 작은 파이썬 스크립트는 자동으로이 일을 생성하는 

183
00:13:35,470 --> 00:13:41,879
 네트워크에 찾을 것이 아니라 시작하려면 약간의 총 당신을 

184
00:13:41,879 --> 00:13:46,509
 처음부터 당신은 일반적으로 몇 가지 기존 제품 내선을 다운로드 할 수 있습니다 및 

185
00:13:46,509 --> 00:13:50,230
 일부 기존 무게 파일과 작업 거기에서 그래서 당신이 생각해야하는 방법 

186
00:13:50,230 --> 00:13:54,139
 우리가 여기에 본 적이 제품 txt 파일이이를 정의하기 전에 것입니다 

187
00:13:54,139 --> 00:13:58,159
 설교자와 무게이 살고있는 네트워크와 멘델의 아키텍처 

188
00:13:58,159 --> 00:14:03,230
 진 일이 그리고 당신이 정말로 검사를하지만, 수 없습니다 카페 모델 파일 

189
00:14:03,230 --> 00:14:07,869
 그것은 그 작동 방법은 이름 위치를 일치 기본적으로 키 - 값 쌍의 

190
00:14:07,869 --> 00:14:13,790
 카페 모델 안에이 때문에 가정의 수호신으로 범위가 이들의 이름과 일치 

191
00:14:13,789 --> 00:14:19,389
 그런데 그가 마지막에 해당 불구과 XC70 무게는-것 

192
00:14:19,389 --> 00:14:24,048
 완전히 연결 층과 알렉스하지 그래서 다음에 당신을 찾을 때 

193
00:14:24,048 --> 00:14:29,600
 자신의 데이터는 카페를 시작하고 당신은 모델과 제품 내선을로드 할 때 

194
00:14:29,600 --> 00:14:33,459
 단지 이름의 키 - 값 쌍을 일치 시키려고하고 카페 사이 대기 

195
00:14:33,458 --> 00:14:35,008
 모델 제품 EXT 

196
00:14:35,009 --> 00:14:39,209
 그래서 같은 이름은 다음 새로운 네트워크는에서 초기화되는 경우 

197
00:14:39,208 --> 00:14:43,008
 가치와 정말 정말 유용하고 좋은 편리하다 프로토 TXT 

198
00:14:43,009 --> 00:14:49,230
 조정하지만, 층 이름은 실제로 해당 계층보다 일치하지 않으면하면 

199
00:14:49,230 --> 00:14:52,980
 이 예를 들어 당신이 국유화 읽을 수있는 방법 그래서 처음부터 초기화 

200
00:14:52,980 --> 00:14:57,810
 당신이했습니다 경우 카페에서 출력 그래서 조금 더 구체적으로 

201
00:14:57,809 --> 00:15:02,250
 아마 모델은 다음이 래리가 완전히 마지막에가는 이미지를 다운로드 

202
00:15:02,250 --> 00:15:06,289
 출력 클래스 과정에서의 연결 층은 천 출력이되지만 

203
00:15:06,289 --> 00:15:09,480
 지금 어쩌면 당신은 당신에 대해 걱정 몇 가지 문제에 대한 10 출력을 원하는 

204
00:15:09,480 --> 00:15:13,149
 당신은 마지막 층을 reindustrialize하는 거 필요가있어, 그것을 실현 

205
00:15:13,149 --> 00:15:17,309
 무작위로 미세 조정 네트워크는 그래​​서 당신이 할 방법은 당신이 필요하다 

206
00:15:17,309 --> 00:15:22,088
 실제로입니다 있는지 확인하기 위해 프로 txt 파일에있는 은신처의 이름을 변경 

207
00:15:22,089 --> 00:15:26,890
 무작위가 아닌 카페 모델과 경우에서 읽는 초기화 

208
00:15:26,889 --> 00:15:30,919
 다음은 실제로 충돌합니다이 작업을 수행하는 것을 잊지 그것은 당신에게 이상한 오류를 줄 것이다 

209
00:15:30,919 --> 00:15:35,419
 모양이이를 저장하려고 할 것이다 원인 정렬하지에 대한 메시지 

210
00:15:35,419 --> 00:15:39,299
 새에서이 열 차원 일에 천 차원의 가중치 행렬 

211
00:15:39,299 --> 00:15:46,129
 파일 및 카페로 작업하는을 정의 할 때 그렇게 다음 단계를 작동하지 않습니다 

212
00:15:46,129 --> 00:15:51,100
 해석 솔버는 당신이 그것을위한 모든 옵션을 볼 수 있습니다 그냥 프로 txt 파일입니다 

213
00:15:51,100 --> 00:15:56,620
 나는이 같은 작은 모양의 무언가에 대한 링크를 준 거 프로필 

214
00:15:56,620 --> 00:16:00,169
 알렉스 밤 그 학습 속도를 정의 할 것이다 당신은 배우고 어쩌면 있도록 

215
00:16:00,169 --> 00:16:04,809
 방법은 k로하고 정규화가 얼마나 자주 그런 모든 것을 확인하지만, 

216
00:16:04,809 --> 00:16:10,169
 이러한 덜 훨씬 덜 복잡 그는위한 프로 TXT 있다는보다 끝나게 

217
00:16:10,169 --> 00:16:15,069
 네트워크이 알렉스 넥타이 다만 어쩌면 십사 라인 당신이되지만 

218
00:16:15,070 --> 00:16:18,530
 실제로 몇 번을 참조 것은 그 사람들은 복잡한의 종류가하려는 경우 

219
00:16:18,529 --> 00:16:22,299
 거래 파이프 라인 위치를 특정의 속도를 학습 나는 11 훈련 그들이 첫 번째 

220
00:16:22,299 --> 00:16:25,039
 네트워크의 일부는 다른 학습 속도 특정 부분과 함께 훈련 할 

221
00:16:25,039 --> 00:16:28,389
 서로 다른 해석 파일의 폭포로 끝날 수있는 네트워크의 

222
00:16:28,389 --> 00:16:31,490
 실제로 우리가 일종의 자신을 미세 조정하는 가장 독립적 인 저를 실행 

223
00:16:31,490 --> 00:16:38,070
 다른 솔버를 사용하여 별도의 단계에서 모델은 모든 일을 한 번, 그래서 그 

224
00:16:38,070 --> 00:16:43,550
 다음은 단지 트레이너 모델 내 조언을 따라하면 당신이 단지를 사용하는 경우 있도록 

225
00:16:43,549 --> 00:16:49,208
 MTB 당신은 그냥 존재, 즉 바이너리 전화에 대한 모든 것을 

226
00:16:49,208 --> 00:16:55,569
 아직 여기 캠페인에 그냥 통과하여 해석하고 TXT 및 

227
00:16:55,570 --> 00:16:59,540
 유럽​​은 미세 조정 인 경우 무게가 파일을 재교육과 금요일 아마 실행합니다 

228
00:16:59,539 --> 00:17:03,659
 아마 오랜 시간 동안 그냥 확인하고 책상을 절감하고 알 수있을 것 

229
00:17:03,659 --> 00:17:08,549
 여기에서 지적하는 한 것은이가에 실행 GPU를 지정할 것입니다 

230
00:17:08,549 --> 00:17:11,209
 마지막 텍스트하지만 당신은 실제로 CPR에서 실행할 수 있습니다 

231
00:17:11,209 --> 00:17:17,288
 마지막에 언젠가 내 음 하나에이 플래그를 설정하고 실제로 최근에 의해 

232
00:17:17,288 --> 00:17:21,048
 올해 카페는 걸쳐 많은 배치를 분할 할 수있는 데이터 병렬 처리를 추가 

233
00:17:21,048 --> 00:17:26,318
 시스템에서 여러 GPU는 실제로이 플래그에 여러 개의 GPU를 추가 할 수 있습니다 

234
00:17:26,318 --> 00:17:29,710
 그냥 모든되어 카페를 말하면 자동으로 여러 배치를 분할합니다 

235
00:17:29,710 --> 00:17:33,600
 컴퓨터에있는 모든 GPU를 통해이 정말 당신은 멀티 GPU를 수행 한 멋진 있도록 

236
00:17:33,599 --> 00:17:51,689
 오 코드 정말 멋진 카페의 한 줄을 작성하지 않고 훈련 그래 

237
00:17:51,690 --> 00:17:57,230
 그래, 정말 문제는 당신이 좀 더 일에 대해 이동하는 방법을 생각 

238
00:17:57,230 --> 00:18:00,778
 당신은 아마 무게를 초기화 할 복잡한 초기화 전략 

239
00:18:00,778 --> 00:18:04,019
 설교자와 모델에서의 여러 부분과 그 같은 방법을 사용하여 

240
00:18:04,019 --> 00:18:07,710
 네트워크는 대답은 당신이 아마 간단한으로 그렇게 할 수 없다는 것입니다 

241
00:18:07,710 --> 00:18:11,278
 당신이 무게와 파이썬에 돈의 종류 할 수있는 메커니즘 그것은 아마 

242
00:18:11,278 --> 00:18:17,669
 내가 우리가 전에 언급 한 것 같아 바로 그래서 그 일에 대해 가지 방법 

243
00:18:17,669 --> 00:18:21,710
 카페는 서로 다른 종류의 많은 다운로드 할 수 있습니다이 정말 좋은 모델이있다 

244
00:18:21,710 --> 00:18:25,919
 이 때문에의 임무에 초반 이었죠 모델과 다른 데이터 세트의이 모델은이다 

245
00:18:25,919 --> 00:18:29,659
 정말 최고의 당신이 알렉스 natin BGG을 가지고 있었다 당신은 거기 주민있어 

246
00:18:29,659 --> 00:18:33,840
 이미 꽤 많이 많이와 정말 좋은 모델을 많이 그래서 거기있다 

247
00:18:33,839 --> 00:18:37,359
 그는 그것이 정말 쉽습니다 카페에 대한 정말 정말 장점입니다입니다 

248
00:18:37,359 --> 00:18:40,428
 누군가 다른 사람의 모델을 다운로드를 가리키는 데이터에서 실행하는 방법 

249
00:18:40,429 --> 00:18:42,350
 데이터 

250
00:18:42,349 --> 00:18:46,298
 내가 언급 한 것처럼 카페는 파이프 라인 인터페이스를 가지고 

251
00:18:46,298 --> 00:18:49,069
 나는 세부 사항으로 뛰어들 수 있다고 생각하지 않습니다 충당하기 위해 너무 많은 일이 있기 때문에 

252
00:18:49,069 --> 00:18:53,378
 여기에 있지만 코스와 카페 파의 일종으로 정말 정말 좋은이 아니다 

253
00:18:53,378 --> 00:18:57,980
 코드를 읽을 필요하고, 그래서 파이썬 인터페이스에 대한 설명서 

254
00:18:57,980 --> 00:18:58,690
 모든 

255
00:18:58,690 --> 00:19:02,730
 파이썬 인터페이스 스트리트 카페는 대부분이 두에 두에 정의되어 있습니다 

256
00:19:02,730 --> 00:19:08,399
 파일이 CPP 파일은 적에게 이야기하기 전에 것을 사용한 경우 파이썬을 향상 사용 

257
00:19:08,398 --> 00:19:13,369
 는 C ++ 클래스의 일부를 마무리하고이에에 다음 걸릴에 노출 

258
00:19:13,369 --> 00:19:17,648
 . 평 실제로 추가 방법을 첨부하고 더 많은 파이썬를 제공 파일 

259
00:19:17,648 --> 00:19:22,469
 인터페이스 당신은 어떤 방법과 데이터 타입의 종류 알고 싶어요 그래서 만약 

260
00:19:22,470 --> 00:19:27,000
 카페 파이프에서 사용할 수있는 것이 가장 좋은 인터페이스 단지를 통해 3을 읽는 것입니다 

261
00:19:27,000 --> 00:19:31,339
 이 두 파일 그리고 그들은 너무 오래 그것은 할 매우 쉽게 그래서 아니에요 

262
00:19:31,339 --> 00:19:37,038
 '예 일반적으로 파이썬 인터페이스는 당신이 아마 수행 할 수 있습니다 꽤 유용 

263
00:19:37,038 --> 00:19:40,558
 미친 체중 초기화 전략은 당신이 뭔가 더 복잡한 작업을 수행해야하는 경우 

264
00:19:40,558 --> 00:19:44,960
 단지 체인 모델 복사보다 그것은 또한 정말 쉽게 단지를 얻을 수 있습니다 

265
00:19:44,960 --> 00:19:48,710
 네트워크는 다음 NumPy와 배열 NumPy와 함께 앞으로 뒤로 실행 

266
00:19:48,710 --> 00:19:53,129
 그래서 예를 들어, 당신은 깊은 꿈과 클래스 등을 구현할 수있다 

267
00:19:53,128 --> 00:19:56,798
 당신이 숙제에 당신도 그렇게 할 수 않았다 유사한 시각화 

268
00:19:56,798 --> 00:20:01,349
 아주 쉽게 그냥 데이터를 취할 필요가 카페에 파이썬 인터페이스를 사용하여 

269
00:20:01,349 --> 00:20:03,899
 다음 네트워크의 다른 부분을 통해 순방향 및 역방향 실행 

270
00:20:03,900 --> 00:20:08,720
 파이썬 인터페이스도 아주 좋은 일을 그냥 추출 할 경우 경우 

271
00:20:08,720 --> 00:20:12,220
 당신 같은 기능을 사용하면 일부 자유 무역 모델이 일부 데이터를 가지고 있고 

272
00:20:12,220 --> 00:20:15,610
 네트워크의 일부에서 기능을 추적 할 다음 어쩌면에 저장 

273
00:20:15,609 --> 00:20:20,259
 디스크가 아마 2005 파일은 아주 쉽게 약간의 다운 스트림 처리했다 

274
00:20:20,259 --> 00:20:25,660
 당신이 할 수있는 파이썬 인터페이스를 수행하는 것은 실제로 카페는 새의 종류가 

275
00:20:25,660 --> 00:20:29,970
 실제로 파이썬에서 레이어를 완전히 정의 할 수 있지만이 기능 

276
00:20:29,970 --> 00:20:33,600
 내가 직접 해본 적이 있지만, 그것은 좋은 것 같지만 냉각 보인다 년대 

277
00:20:33,599 --> 00:20:37,259
 단점은 그 층이 나 CPU가 될 것입니다 그래서 우리는 대한 이야기​​입니다 

278
00:20:37,259 --> 00:20:41,809
 당신이 편지를 쓰는 경우 CPU와 GPU 사이의 통신 병목 

279
00:20:41,809 --> 00:20:46,460
 파이썬은 모든 전후 패스가 난 오버 헤드가 고정됩니다 

280
00:20:46,460 --> 00:20:51,289
 파이프와 전선으로 도움이 될 수 있습니다 하나의 좋은 장소 있지만 전송하지 

281
00:20:51,289 --> 00:20:58,450
 사용자 정의 손실 함수 그건 당신이 마음에 그렇게 유지 수있는 일이 어쩌면 그래서 

282
00:20:58,450 --> 00:21:02,450
 가톨릭 장점과 단점의 빠른 개요이 정말 내 관점에서 

283
00:21:02,450 --> 00:21:06,049
 당신 싶어하는 모든 경우 종류의 간단한 기본 피드 포워드 네트워크를 훈련 

284
00:21:06,049 --> 00:21:09,730
 특히 분류 및 캐시는 물건을 얻을 정말 쉽습니다 

285
00:21:09,730 --> 00:21:12,880
 당신을 실행하면 자신이 방금 이러한 모든 사용하는 코드를 작성할 필요가 없습니다 

286
00:21:12,880 --> 00:21:17,660
 도구를 사전이 내장 그것은 파이썬 인터페이스를 실행하는 것은 매우 쉽다 

287
00:21:17,660 --> 00:21:21,259
 조금 사용하기위한 아주 좋은 조금 더 복잡한 사용 사례에 대해 작동합니다 

288
00:21:21,259 --> 00:21:25,329
 당신이 정말로이있을 때 일이 정말 미친 얻을 때하지만 성가신 될 수 있습니다 

289
00:21:25,329 --> 00:21:29,299
 특히 그들이 할 수있는 반복 모듈 패턴 회장 같은 큰 네트워크 

290
00:21:29,299 --> 00:21:33,450
 당신이 원하는 위치 지루한와 같은 재발 네트워크와 같은 것들에 대한 수 

291
00:21:33,450 --> 00:21:37,519
 네트워크의 다른 부분 사이의 공유 기다립니다 종류 회사의 종류 일 수있다 

292
00:21:37,519 --> 00:21:41,559
 카페에서 성가신의 그것은 가능하지만 아마 사용할 수있는 가장 좋은 것은 아니다 

293
00:21:41,559 --> 00:21:46,250
 내 관점에서 다른 큰 단점이 및 다른 단점 

294
00:21:46,250 --> 00:21:50,220
 당신이 카페에서 은신처의 자신의 유형을 찾을 때 갖는 끝날 것입니다 

295
00:21:50,220 --> 00:21:55,440
 그것이 당신에게 매우 빠른 개발주기를 제공하지 않습니다하지 그래서 C ++ 코드를 작성하는 

296
00:21:55,440 --> 00:22:00,769
 그래서 그 그건 그래서 고통의 종류의 많은 종류의 당신에게 편지를 쓰고 있어요 

297
00:22:00,769 --> 00:22:04,750
 우리의 세계는 카페의 여행을하는 간단한 질문이 있다면, 그래서 선풍 이유 

298
00:22:04,750 --> 00:22:06,669
 네 

299
00:22:06,669 --> 00:22:14,028
 교차 검증 및 카페 찾을 시도 할 수 있습니다이 txt 기차 발파라이소에서 매우 

300
00:22:14,028 --> 00:22:19,159
 교육 단계와 테스트 단계는 그래서 일반적으로 약 기차처럼 좋아 

301
00:22:19,159 --> 00:22:20,269
 제품 내선 

302
00:22:20,269 --> 00:22:24,960
 제품 내선을 적용하고 손하지만 테스트에서 작업에에서 사용되는 배포 

303
00:22:24,960 --> 00:22:33,409
 흔적 제품 내선의 위상은 그게 다야의 유효성 확인에 사용됩니다 

304
00:22:33,409 --> 00:22:39,820
 다음 하나는 토치 그래서 토치 정말 내 그래서 캐비닛에 대해 알고있다 

305
00:22:39,819 --> 00:22:42,980
 내가 여기 편견 조금 그래서 개인적으로 좋아 단지에 그를 얻을 수 

306
00:22:42,980 --> 00:22:46,259
 오픈 나는 꽤 많이 내 자신에 거의 독점적으로 토치를 사용했던 것을 

307
00:22:46,259 --> 00:22:51,749
 작년에 정도 횃불 그래서 프로젝트는 것 NYU 출신 

308
00:22:51,749 --> 00:22:56,450
 C에서 최대 대신에 기록하고 페이스 북 참으로 마음에 많이 사용되는 

309
00:22:56,450 --> 00:23:02,409
 특히 나는 큰 중 하나 있도록 토치를 사용하는 트위터에서도 사람들을 많이 생각 

310
00:23:02,409 --> 00:23:05,309
 과정에서 사람들을 괴물 일들이 당신이 대신 작성해야한다는 것입니다 

311
00:23:05,308 --> 00:23:11,038
 나는 듣지 또는 토치 작업을 시작하기 전에 사용 된 적이 적이있는 

312
00:23:11,038 --> 00:23:16,700
 하지만 실제로 유혹 가장 높은이 높은 수준의 스크립트는 것을 너무 나쁘지 않다 

313
00:23:16,700 --> 00:23:20,999
 더 실행할 수 있도록 정말 임베디드 디바이스를위한 것입니다 언어 

314
00:23:20,999 --> 00:23:24,720
 효율적으로는 많은 방법에서 자바 스크립트와 매우 유사 많이있어 

315
00:23:24,720 --> 00:23:29,749
 그래서 루에 대한 또 다른 좋은 점은 그것이 의미가 있기 때문에 내장에서 실행할 수 있다는 것입니다 

316
00:23:29,749 --> 00:23:33,929
 당신이 실제로 루프를 위해 할 수있는 장치는 정말 빨리하고 성화 당신은 알고있다 

317
00:23:33,929 --> 00:23:37,149
 당신은 진짜로 그건 천천히 것 for 루프에서 어떻게 파이썬에서라면 

318
00:23:37,148 --> 00:23:40,798
 실제로 적시를 사용하기 때문에 성화에의 할 사실은 완전히 잘 

319
00:23:40,798 --> 00:23:46,249
 이러한 일들이 정말 빨리 만들 수 컴파일과 성화는 우리의 최신 가장입니다 

320
00:23:46,249 --> 00:23:50,200
 이 기능 언어 기능이 인 것을 중요 자바 스크립트 

321
00:23:50,200 --> 00:23:54,058
 그것은 다른에 주위에 콜백을 통과 전달하는 매우 흔한 일류 시민 

322
00:23:54,058 --> 00:24:01,200
 코드의 일부는 또한 프로토콜 상속 곳의이 아이디어를 가지고있다 

323
00:24:01,200 --> 00:24:05,200
 그들은 당신이 생각할 수있는 테이블 루아에있는 일종의 하나의 데이터 구조의 것 

324
00:24:05,200 --> 00:24:09,558
 당신이 일을 구현할 수있는 자바 스크립트 객체와 매우 유사되고있는 

325
00:24:09,558 --> 00:24:13,378
 객체 지향 프로그래밍 같은 비슷한에 프로토 타입 상속을 사용하여 

326
00:24:13,378 --> 00:24:18,428
 방법이 자바 스크립트에서와 그리고 도시의 하나 단점 중의 하나로서 

327
00:24:18,429 --> 00:24:19,929
 실제로 표준 라이브러리 

328
00:24:19,929 --> 00:24:24,820
 취급 문자열과 이것 저것 할 수있다처럼 때로는 성가신 종류의 물건입니다 

329
00:24:24,819 --> 00:24:28,999
 아마 가장 성가신 가시고의 종류는 그렇게 모든 인덱스의 하나입니다 

330
00:24:28,999 --> 00:24:33,058
 네 루프에 대한 당신의 직관은 한 동안 있지만 다른에 대해 조금 꺼집니다 

331
00:24:33,058 --> 00:24:37,528
 보다가 데리러 아주 쉽게 그리고 나는이 웹 사이트에 여기에 링크를 준 

332
00:24:37,528 --> 00:24:41,618
 당신이 15 분 루아를 배울 수 있다고 주장하는 것은 그것은 약간있을 수 있습니다 

333
00:24:41,618 --> 00:24:45,209
 그들은 그것을 조금 지나치게 될 수 있으므로 이상하지만 난 그것을 아주 쉽게 생각 

334
00:24:45,210 --> 00:24:50,298
 그래서 주요 아이디어 뒤에 꽤 빨리 그것을 선택하고 코드를 작성 시작하기 

335
00:24:50,298 --> 00:24:55,398
 토치 그래서 너희들에 NumPy와 많이 작업 된이 텐서 클래스 당신의 

336
00:24:55,398 --> 00:24:59,548
 할당 및 할당 종류의 구조화하는 방법은 NumPy와 것입니다 

337
00:24:59,548 --> 00:25:03,329
 배열은 당신에게 어떤 방법으로 당신이 원하는 데이터를 조작하는이 정말 쉬운 방법을 제공합니다 

338
00:25:03,329 --> 00:25:06,798
 다음과 같은 축적 다른 추상화의 수 높은 비율을 사용할 수 있습니다 

339
00:25:06,798 --> 00:25:10,720
 라이브러리와 이것 저것하지만 정말 NumPy와 배열이 당신을 할 것으로 알려져 

340
00:25:10,720 --> 00:25:16,909
 당신이 그렇게 완벽한 유연성에 원하는 방식으로 숫자 데이터를 조작 

341
00:25:16,909 --> 00:25:20,580
 통화하는 경우 어쩌면 여기 봐 여기에 일부 NumPy와의 예 

342
00:25:20,579 --> 00:25:24,918
 지금 우리가 그냥 패스에 대한 간단한을 계산하고 의해 아주 잘 알고 있어야 코드 

343
00:25:24,919 --> 00:25:31,990
 냉기 철도 네트워크의 어쩌면 블랙은 여기 최선의 선택은 아니었지만 우리는있어 

344
00:25:31,990 --> 00:25:36,569
 우리는 우리는 우리가 어떤 어떤 상수 일부 경쟁하고 경쟁하는 일을하고있어 

345
00:25:36,569 --> 00:25:40,408
 가중치는 어떤 임의의 데이터를 얻고있다 그리고 우리는 매트릭스에서 집회를 곱하고있는 

346
00:25:40,409 --> 00:25:44,789
 곱 또 다른 주요 그래서 그 그 심판을 작성하는 것은 매우 간단이고 

347
00:25:44,788 --> 00:25:49,538
 실제로이 이제 불을 지른 답변에 거의 120 번역이 

348
00:25:49,538 --> 00:25:53,970
 오른쪽이 동일한 코드를하지만, 그래서 여기에 불을 지른 답변을 사용하고 

349
00:25:53,970 --> 00:25:58,509
 우리의 가중치를 우리는 우리의 뒷부분 입력 크기를 정의하고 모든 우리는 정의하고 그 

350
00:25:58,509 --> 00:26:02,929
 이는 단지 불을 지른 대답은 우리가있어 임의의 입력 벡터를 얻고 있었다있다 

351
00:26:02,929 --> 00:26:07,929
 이 행렬을하고있다 전진 패스를하고 우리의 스폰서까지 번식이 

352
00:26:07,929 --> 00:26:09,179
 C-최대 

353
00:26:09,179 --> 00:26:13,149
 진짜 문제이고 우리가 사용하는 코어를 계산할 수 요소 현명한 최대 

354
00:26:13,148 --> 00:26:17,089
 코드의 일반적인 거의 모든 종류의 사용에 있도록 다른 행렬 곱셈 

355
00:26:17,089 --> 00:26:18,689
 심판을 거래하는 것은 매우 간단합니다 

356
00:26:18,690 --> 00:26:22,460
 꽤 많이 사용에 거의 하나씩 라인 별 번역이 

357
00:26:22,460 --> 00:26:25,400
 불을 지른 대답 대신 

358
00:26:25,400 --> 00:26:28,880
 그래서 또한 교환 및 다른 사용하기 정말 쉬운 것이 심판의 기억 

359
00:26:28,880 --> 00:26:33,690
 우리는이 광고에 대해 얘기 데이터 유형은 최소한의 마지막 강의를 싫증하지만, 

360
00:26:33,690 --> 00:26:38,500
 당신이 할 필요가 아마 32 비트 부동 소수점로 전환 할 NumPy와 

361
00:26:38,500 --> 00:26:43,049
 이 다른 데이터 유형으로 데이터를 캐스팅하고는 아주 아주 있다고 밝혀 

362
00:26:43,049 --> 00:26:47,589
 뿐만 아니라 우리의 데이터 유형이이 강도가 지금 있음을 고문 할 쉽게 

363
00:26:47,589 --> 00:26:52,990
 우리는 쉽게 다른 데이터 유형으로 우리의 데이터를 전송할 수 있지만, 여기 어디이있어 

364
00:26:52,990 --> 00:26:56,130
 년 그래서 진짜 이유 등이 다음 슬라이드 고문은 무한 이유하지만 

365
00:26:56,130 --> 00:27:02,020
 NumPy와보다 나은 즉 GPU는 또 다른 데이터가 그렇게 할 때 입력 한 것을이다 

366
00:27:02,019 --> 00:27:07,879
 당신이 횃불의 GPU에서 코드를 실행할 싶어 할 때 당신은 당신이 가져 이것을 사용 옳다 

367
00:27:07,880 --> 00:27:11,630
 다른 패키지와 다른 시간을 지른 또 다른 데이터 형식이 

368
00:27:11,630 --> 00:27:16,810
 텐서와 지금이 다른 데이터 유형에 텐서를 캐스팅하고 지금은 

369
00:27:16,809 --> 00:27:21,819
 GPU에서 살고 텐서에 수치 연산의 종류를 실행 단지 

370
00:27:21,819 --> 00:27:26,500
 정말 정말 간단하고 토치 그냥 일반 쓸 수 있도록 GPU에서 실행 

371
00:27:26,500 --> 00:27:34,220
 tenser 과학 컴퓨팅 코드는 I GPU를 실행하고 정말 빨리 그래서 이런 식으로 내가 할 수 

372
00:27:34,220 --> 00:27:37,819
 이 텐서 정말 당신은 유사한 그들을 제기 NumPy와 생각해야되는 것을 

373
00:27:37,819 --> 00:27:41,689
 및 방법의 종류 만에 문서의 많은 거기에 당신 

374
00:27:41,690 --> 00:27:46,250
 여기까지 10 서비스 내에서 작동하고이 문서를 얻을 수있는 것은 슈퍼 아니다 

375
00:27:46,250 --> 00:27:53,950
 완전한하지만 당신이 다음 있도록에서 살펴 보셔야합니다 있도록이 나쁘지 않아 야하지만, 

376
00:27:53,950 --> 00:27:58,200
 실제로 당신은 정말 대신 횃불에 너무 많이 텐서를 사용하지 결국 

377
00:27:58,200 --> 00:28:02,880
 그래서 신경 네트워크의 끝이라는 다른 패키지를 사용하고 이것입니다 

378
00:28:02,880 --> 00:28:06,800
 실제로 그냥 신경 네트워크 패키지를 정의하는 매우 얇은 래퍼 

379
00:28:06,799 --> 00:28:10,930
 이 텐트의 관점에서이 텐트의 조건은 당신이 생각해야 개체 

380
00:28:10,930 --> 00:28:15,049
 이 숙제 코드의 BPR 더 산업용 강도 버전처럼 인 것으로 

381
00:28:15,049 --> 00:28:20,240
 기본이이이 열 번째와 배열이 텐서 추상화가 어디 

382
00:28:20,240 --> 00:28:24,480
 다음은 좋은 깨끗한에서 그 꼭대기에 방향족 라이브러리를 구현 

383
00:28:24,480 --> 00:28:30,410
 인터페이스는 그래서 여기에 우리를 N 패키지를 사용 래리 애들러 네트워크에 동일합니다 

384
00:28:30,410 --> 00:28:33,900
 이 거 순차적의 스택 수 그래서 우리의 네트워크가 순차적가 정의 

385
00:28:33,900 --> 00:28:38,360
 작업을 우리가 완전히 연결되어 선형이 처음거야 거입니다 

386
00:28:38,359 --> 00:28:41,759
 우리의 입력이 마케팅을 언급에서 우리는거야 난간을 가지고 언급 

387
00:28:41,759 --> 00:28:48,420
 다른 대출은 지금 우리가 실제로 두 번째의 무게와 그라디언트를 얻을 수 있습니다 

388
00:28:48,420 --> 00:28:52,070
 지금 대기가 될 것이 얻을 매개 변수 방법을 사용하여 각각에 대한 대답 

389
00:28:52,069 --> 00:28:55,750
 네트워크 및 졸업생 모든 방법이있을 것이다 단일 불을 지른 답변 

390
00:28:55,750 --> 00:29:00,490
 우리가 생성 할 수 있습니다 위의 모든 재료에 대해 하나의 횃불 대답을 할 것이다 

391
00:29:00,490 --> 00:29:05,730
 어떤 임의의 데이터는 이제 앞으로 패스에 우리는 단지의 형식 매트를 호출 

392
00:29:05,730 --> 00:29:11,599
 이 우리에게 컴퓨터 손실에 대한 우리의 점수 우리는이를 제공합니다 우리의 데이터를 사용하여 객체 

393
00:29:11,599 --> 00:29:16,769
 그래서 우리는 컴퓨터에 의해 잃어버린 우리의 손실 함수입니다 별도의 기준 객체 

394
00:29:16,769 --> 00:29:21,289
 기준의 네 번째 메서드를 호출하면 지금 우리는 우리의 예측을 수행 한 

395
00:29:21,289 --> 00:29:27,279
 우리가 처음 설정 쉽고 뒤로 패스 20 호출 손실 함수에 역 

396
00:29:27,279 --> 00:29:31,609
 내가 지금 일에있어 다음 역이는의 그라데이션을 모두 업데이트했습니다 

397
00:29:31,609 --> 00:29:35,319
 대학원에서 네트워크는 우리가 그냥 아주 쉽게 그라데이션 물건을 만들 수 있습니다 params는 

398
00:29:35,319 --> 00:29:40,419
 그래서 이것은 학습의 반대에 의해 졸업생을 곱한 것 

399
00:29:40,420 --> 00:29:44,130
 레이트하고 간단한 그래디언트 디센트 갱신의 방법에 추가 

400
00:29:44,130 --> 00:29:50,400
 그것은 어쩌면 조금했을 모든 권한을의 권리 

401
00:29:50,400 --> 00:29:53,560
 더 명확하지만 우리는 우리가 기능을 잃은 무게 졸업생을하지 않은 

402
00:29:53,559 --> 00:30:00,730
 우리는 앞으로에서 임의의 데이터를 얻을 뒤로 업데이 트를 확인하고 같이 

403
00:30:00,730 --> 00:30:03,930
 그 대답보고에서 기대할 수있는 것이이 일을 실행할 수 있도록하는 것은 매우 쉽다 

404
00:30:03,930 --> 00:30:09,570
 GPU에 우리가 몇 가지 새로운 패키지를 가져 GPU에서 이러한 네트워크에서 실행 

405
00:30:09,569 --> 00:30:14,519
 고문을 통해 모든 것을 두 가지 버전이 끝과 우리 

406
00:30:14,519 --> 00:30:17,930
 그냥이 다른 데이터 유형으로 우리의 네트워크와 우리의 손실 함수를 캐스팅해야 

407
00:30:17,930 --> 00:30:23,490
 우리는 또한 우리의 데이터와 레이블을 캐스팅 할 필요가 지금이 모든 네트워크는 것 

408
00:30:23,490 --> 00:30:28,660
 그것은 그 40 어땠는지 지금 매우 쉽다는 그래서 실행하고 GPU에 대한 교육을 

409
00:30:28,660 --> 00:30:31,320
 코드 라인은 우리가 완전히 연결 네트워크를 작성했습니다 우리는에 훈련 할 수있다 

410
00:30:31,319 --> 00:30:37,089
 여기에 GPU하지만 하나의 문제는 우리가 그냥 바닐라 그라데이션을 사용하는 것입니다 

411
00:30:37,089 --> 00:30:41,000
 너무 큰되지 않고 하강 당신은 할당과 같은 다른 것들에 본대로 

412
00:30:41,000 --> 00:30:45,329
 아웃 실제로는 훨씬 더 나은 작업에 불쑥 우리의 혼란에 이렇게 것을 해결하기 위해 

413
00:30:45,329 --> 00:30:50,319
 성화는 우리에게 다시 사용하기 때문에 낙관적 아주 쉽게 기회 패키지를 제공합니다 우리 

414
00:30:50,319 --> 00:30:51,799
 바로 여기에 새로운 패키지를 가져 

415
00:30:51,799 --> 00:30:57,799
 여기 그리고 지금 무엇을 변경하는 것은 우리가 실제로이 콜백을 정의 할 필요가있다 

416
00:30:57,799 --> 00:31:02,569
 우리가 앞으로 전화 및 역방향 명시 적으로 제외되었다 전에 있도록 기능 

417
00:31:02,569 --> 00:31:06,960
 해결할 대신 우리는을 실행이 콜백 함수를 찾을거야 

418
00:31:06,960 --> 00:31:10,750
 네트워크는 앞으로 데이터를 뒤로하고 손실과 기울기를 반환 

419
00:31:10,750 --> 00:31:15,400
 지금 우리의 네트워크에 업데이트 정지 실제로이 콜백을 통과 할 수 있도록하는 

420
00:31:15,400 --> 00:31:21,259
 Optim을 패키지에서이 아담 방법과 기능 때문에이이 어쩌면이다 

421
00:31:21,259 --> 00:31:26,940
 조금 어색하지만 당신은 우리가 단지를 사용하여 업데이트 규칙의 어떤 종류를 사용할 수 있습니다 알고 

422
00:31:26,940 --> 00:31:31,430
 우리가 전에 한 어떤에서 변화의 몇 라인은 다시는 매우 간단합니다 

423
00:31:31,430 --> 00:31:38,900
 단지 우리가 본 바로 위하여 가고 모든 캐스팅하여 GPU에서 실행에 추가 

424
00:31:38,900 --> 00:31:44,220
 카페 카페 일종의 다음의 용어와 레이어와 카페가 모든 것을 구현 

425
00:31:44,220 --> 00:31:48,750
 그 사이 정말 열심히 구분 및 토치의 은신처 그들은 우리는하지 않습니다 

426
00:31:48,750 --> 00:31:52,400
 정말이 구별 모든 것을 그릴 수없는 것은 전체 그래서 그냥 모델입니다 

427
00:31:52,400 --> 00:31:59,750
 네트워크 모듈이며, 또한 각각의 모듈 래리 그래서 모듈은 

428
00:31:59,750 --> 00:32:03,650
 구현되는 틀에 박힌 생활 대신에 정의되어 단지 클래스는 

429
00:32:03,650 --> 00:32:08,880
 그 대답의 API를 사용하므로 이러한 모듈은 꽤있어 서면 법부터입니다 

430
00:32:08,880 --> 00:32:13,260
 여기에 많은 이해하기 쉬운 완전 이제 연결된 완전하다 

431
00:32:13,259 --> 00:32:17,039
 래리 연결이 당신이 그냥 볼 수있는 생성자 

432
00:32:17,039 --> 00:32:23,210
 가중치 및 바이어스 용으로이 텐서 API로 인해 텐트 설정 

433
00:32:23,210 --> 00:32:28,100
 성화는 우리가 쉽게 이러한 모든 층보다 GPU와 CPU에 동일한 코드를 실행할 수 있습니다 

434
00:32:28,099 --> 00:32:32,359
 단지 텐서 API의 관점에서 작성하고 Heasley 모두에서 실행됩니다 

435
00:32:32,359 --> 00:32:37,529
 장치이므로 이러한 모듈은 전후 원경 구현해야 

436
00:32:37,529 --> 00:32:42,670
 앞으로 아기 때문에 여기의 예제는 출력을 업데이트 부르기로 결정 

437
00:32:42,670 --> 00:32:47,250
 의 전체 텍스트에 대한 업데이트 출력은 나중에 실제로 몇 가지 경우가있어 그들이 

438
00:32:47,250 --> 00:32:50,480
 다시 비 대 나와 함께 여기 몇 가지 경우를 처리해야하는 날 

439
00:32:50,480 --> 00:32:55,170
 다시 부분에 있지만, 다른 것보다 있지만, 사용하기 전에 반드시 숙지 아주 쉬워야한다 

440
00:32:55,170 --> 00:33:00,830
 더 뒤로받는 방법 업데이트 대학원 입력 한 쌍의 거기 통과 

441
00:33:00,829 --> 00:33:03,970
 상류 구배 및 계산하는 그라디언트 존중 

442
00:33:03,970 --> 00:33:09,160
 입력 및 다시 그냥 텐서 API로 구현됩니다 그래서 그것은 매우 쉽게 

443
00:33:09,160 --> 00:33:14,279
 일의 그 조금을 이해 그냥 같은 유형은 숙제 우리에보고 

444
00:33:14,279 --> 00:33:17,990
 또한 구현하고 기울기를 계산하는 잡아 매개 변수를 축적 

445
00:33:17,990 --> 00:33:21,480
 네트워크의 무게에 대하여 당신은 생성자에서 본대로 

446
00:33:21,480 --> 00:33:25,610
 편견의 무게가 인스턴스 변수이 모듈에서 개최되며, 

447
00:33:25,609 --> 00:33:30,309
 대학원 매개 변수는 업스트림에서 그라디언트를 받게됩니다 축적과 축적 

448
00:33:30,309 --> 00:33:34,940
 다시 상류 라디안과 관련하여 파라미터 그라디언트 

449
00:33:34,940 --> 00:33:39,809
 단지 텐서 API를 사용하여 매우 간단합니다 

450
00:33:39,809 --> 00:33:44,200
 토치 실제로 사용 가능한 다른 모듈의 톤 여기에 문서를 가지고 

451
00:33:44,200 --> 00:33:46,980
 당신은 단지에 가면 날짜가 조금있을 수 있지만, 당신은 모든 확인할 수 있습니다 일어나서 

452
00:33:46,980 --> 00:33:51,460
 파일은 당신에게 놀 수있는 모든 케이크를 제공하는 그는 실제로 얻을 수있어 

453
00:33:51,460 --> 00:33:55,930
 많은 그래서 그냥 포인트 아웃이이 전쟁 전 그냥 날 추가 몇 업데이트 

454
00:33:55,930 --> 00:34:00,750
 횃불은 항상 당신이 당신의 네트워크를 추가 할 수있는 새로운 모듈을 추가, 그래서 지난 주 

455
00:34:00,750 --> 00:34:06,390
 이는 꽤 재미 있지만, 이러한 기존의 모듈이 충분하지 않은 때이다 

456
00:34:06,390 --> 00:34:10,579
 그냥이를 구현할 수 있기 때문에, 그래서 자신을 쓰기 실제로 매우 쉽게 

457
00:34:10,579 --> 00:34:13,989
 텐서 API를 사용하여 단지를 구현하는이 tenser를 사용하는 것 

458
00:34:13,989 --> 00:34:17,259
 전후 그것은에 구현 층보다 훨씬 더 어렵다 

459
00:34:17,260 --> 00:34:21,890
 그래서 여기에 숙제 단지 작은 예입니다 이것은 단지 걸리는 바보 모듈입니다 

460
00:34:21,889 --> 00:34:28,210
 입력과 2로 곱하면 우리가 업데이트 그래프를 구현 볼 수 있습니다 

461
00:34:28,210 --> 00:34:31,849
 템플릿과 지금 우리는 단지 스물 라인 새 레이어과 토크를 구현 한 

462
00:34:31,849 --> 00:34:35,929
 코드는 그 정말 쉽게 후 다른 코드를 사용하는 것은 매우 쉽다 

463
00:34:35,929 --> 00:34:40,710
 그냥 가져 와서 나는 당신의 네트워크를 추가 등등과 정말 멋진 할 수 있습니다 

464
00:34:40,710 --> 00:34:44,920
 이것은 당신이 할 수있는 단지 텐서 API이기 때문에 이것에 대해 것은 무엇이든 종류 

465
00:34:44,920 --> 00:34:48,579
 임의의 일이 당신 앞으로 이러한 내부 원하고 필요한 경우 뒤로 

466
00:34:48,579 --> 00:34:52,730
 아마 코드 또는 아무것도 또는 루프 또는 복잡하고 부모를 위해해야​​ 할 일 

467
00:34:52,730 --> 00:34:56,980
 어떤 어떤 종류의보다 밖으로 드롭 또는 합리화 확률 일 

468
00:34:56,980 --> 00:34:59,949
 당신은 기대 할 뒤로 당신을 통과 코드의 어떤 종류 

469
00:34:59,949 --> 00:35:03,500
 그것은 일반적으로 매우 간단 매우 그래서 이러한 모듈 내부에 직접 구현 

470
00:35:03,500 --> 00:35:11,500
 토치 있도록하지만, 물론 선수들과 토치의 자신의 새로운 유형을 쉽게 구현할 수 

471
00:35:11,500 --> 00:35:14,250
 자신의 개별 레이어를 사용하는 것은 매우 유용하지 않습니다 

472
00:35:14,250 --> 00:35:16,960
 우리는 더 큰 네트워크로 함께 스티치 할 사람이 필요 

473
00:35:16,960 --> 00:35:21,220
 지금까지이 성화는 우리가 이미 앞의 예에서 일을보고 용기를 사용 

474
00:35:21,219 --> 00:35:26,549
 이는이 순차적 컨테이너 그래서 결과적 컨테이너 그냥 스택이다 

475
00:35:26,550 --> 00:35:29,950
 모든 우리는 이전의 출력을 수신하여 하나있어 모듈 

476
00:35:29,949 --> 00:35:35,639
 하나는 그냥 가서 그게 아마 당신이 수도 가장 일반적으로 사용되는 또 다른 하나 

477
00:35:35,639 --> 00:35:40,799
 볼이 입력이 있고 경우이 부모가 어쩌면 테이블이 성기입니다 

478
00:35:40,800 --> 00:35:44,289
 댄 동일한 입력에 다른 모듈에 다른 적용 할 

479
00:35:44,289 --> 00:35:49,099
 콘텐츠 테이블 당신은 그렇게 당신은 다른 출력 셀레스트를받는 

480
00:35:49,099 --> 00:35:53,280
 당신이 입력의 목록이있는 경우는 병렬 테이블로 볼 수 있습니다 당신이 원하는 

481
00:35:53,280 --> 00:35:57,500
 다음 다른에리스트의 각 요소를 다른 모듈을 수행 할 수 있습니다 적용 

482
00:35:57,500 --> 00:36:04,588
 상황이 오면 건설의 종류에 대한 병렬 타 보르 테이블을 사용하지만, 

483
00:36:04,588 --> 00:36:08,980
 정말 그렇게 실제로 내가 당신에게하는 그 용기를 복잡 

484
00:36:08,980 --> 00:36:13,480
 이론적으로 쉽게해야하는 보조 당신을 사과 단지에 대해 구현하는 것이 가능합니다 

485
00:36:13,480 --> 00:36:16,980
 원하는하지만 정말 복잡 묶는 연습에 정말 털이 수 있습니다 

486
00:36:16,980 --> 00:36:21,480
 토치 페넌트라는 다른 패키지를 제공하므로 그 용기를 사용하는 것 

487
00:36:21,480 --> 00:36:23,230
 당신이 훅 수 있습니다 그래프 

488
00:36:23,230 --> 00:36:28,210
 컨테이너 훅 가지 더 복잡한 토폴로지 아주 쉽게 그렇게 

489
00:36:28,210 --> 00:36:32,400
 우리가있는 경우 여기에 우리가 3 개의 입력이있는 경우 어쩌면 우리가 하나를 생성 할 예입니다 

490
00:36:32,400 --> 00:36:36,930
 출력과 우리는 아주 간단 업데이트 규칙을 생성하려는 

491
00:36:36,929 --> 00:36:40,379
 우리는 많은 봤어요 계산 그래프의이 유형에 해당 

492
00:36:40,380 --> 00:36:44,869
 당신이 실제로 구현할 수 있도록 문제의 다른 유형에 대한 강의에서 배 

493
00:36:44,869 --> 00:36:49,430
 이 단지 사용하여 고급 병렬 및 순차 및 테이블 성기하지만 그것을 

494
00:36:49,429 --> 00:36:53,009
 당신 싶어이 같은 일을 할 때 그래서 아주의 질량의 종류 수 

495
00:36:53,010 --> 00:36:58,470
 이 그래프 코드가 대신 있도록 그래프를 전송하는 것이 일반적 그래서 여기이 매우 쉽습니다 

496
00:36:58,469 --> 00:37:03,179
 함수는 그래프를 사용하여 모듈을 구축하고 그래서 여기를 반환하는 것입니다 

497
00:37:03,179 --> 00:37:09,129
 우리는 그래프 패키지를 가져온 다음 여기 안에이 돈의 비트입니다 

498
00:37:09,130 --> 00:37:14,329
 구문은 그래서 이것은 실제로는이 상징적 인 변수를 발견하는 텐서 아니다 

499
00:37:14,329 --> 00:37:19,480
 그래서 이것은 우리의 우리 텐트 또는 객체로 XY 및 Z를 받으려고하는 것을 말하고있다 

500
00:37:19,480 --> 00:37:25,300
 입력과 현재 점유율은 실제로 그렇게 그 입력에 상징적 인 작업을하고 있었다 

501
00:37:25,300 --> 00:37:26,840
 여기에 우리가 말을하는지 

502
00:37:26,840 --> 00:37:32,700
 우리는 우리가 두 번 연주 한 할 X & Y의 점별 버전을 가지고 싶어 

503
00:37:32,699 --> 00:37:38,159
 및 수 ANZ 저장소의 곱셈과 A & B의 지금 점별 판과 

504
00:37:38,159 --> 00:37:42,159
 이러한 실제적인 tenser이 지금의 객체이다 다시 저장하고보고 

505
00:37:42,159 --> 00:37:45,109
 당신이 구축하는 데 사용되는 기호 참조의 종류 

506
00:37:45,110 --> 00:37:50,420
 계산 백그라운드에서 그래프와 지금 우리가 실제로 반환 할 수 있습니다 

507
00:37:50,420 --> 00:37:55,159
 우리는 우리의 모듈은 입력 XY 및 Z 출력을 것이라고 여기 모듈 

508
00:37:55,159 --> 00:38:00,920
 볼이 엔드 IG 모듈은 실제로 우리에 부합하는 객체를 제공합니다 

509
00:38:00,920 --> 00:38:05,559
 그럼 우리가 구축 한 후 그 계산을 구현하는 모듈 API 

510
00:38:05,559 --> 00:38:10,619
 몬트리올 우리는 콘크리트 법원이 답변을 지른 구성 할 수 있습니다 다음에 그들을 먹여 

511
00:38:10,619 --> 00:38:19,170
 실제로 기능을 너무 횃불 사실은 꽤 계산됩니다 모듈 

512
00:38:19,170 --> 00:38:22,670
 초반 이었죠 모델을 잘 할 수있는 패키지라는로드 캠페인이있다 

513
00:38:22,670 --> 00:38:27,050
 당신은 카페에서 사전 시험 모델의 많은 다른 유형을로드하고는거야 

514
00:38:27,050 --> 00:38:31,590
 그들의 고문의 등가물로 변환 당신은 카페를로드 할 수 있습니다 

515
00:38:31,590 --> 00:38:35,539
 제품 내선 및 카페 모델 파일과는의 거대한 스택에 설정합니다 

516
00:38:35,539 --> 00:38:39,929
 연속 시장은, 카페 슈퍼 일반 보하지로드하고 특정 작동 

517
00:38:39,929 --> 00:38:44,649
 네트워크 그러나 특정 부하 카페의 종류는 알렉스를하지로드 할 것이며, 

518
00:38:44,650 --> 00:38:49,660
 그들은 아마 가장 일반적으로 몇 가지있어 수 있도록 캠페인 및 PGG이 있습니다 사용 

519
00:38:49,659 --> 00:38:54,259
 또한 몇 가지 다른 구현 당신은 횃불로 구글 매트에로드 

520
00:38:54,260 --> 00:38:58,520
 당신이 재시도 구글을로드 할 수 있도록 그 모델 성화에 실제로 매우 

521
00:38:58,519 --> 00:39:01,869
 최근 페이스 북은 잔류 네트워크를 나서서 다시 구현 

522
00:39:01,869 --> 00:39:07,900
 바로 횃불 최대 알렉스 사이 때문에 그들은 그것을 위해 초반 이었죠 모델 출시 

523
00:39:07,900 --> 00:39:11,849
 BG 그룹과 ResNet에서 캠페인되지 그게 아마 모든 것을 당신을 생각 

524
00:39:11,849 --> 00:39:17,869
 이다 대부분의 사람들이 다른 점을 이용하려는 모든 초반 이었죠 모델 필요 

525
00:39:17,869 --> 00:39:21,549
 횃불이 미끼를 사용하기 때문에 우리는 패키지를 설치 핍 사용하고있을 수 없습니다 

526
00:39:21,550 --> 00:39:24,920
 쉽게 새로운 설치할 것 막사라는 또 다른 매우 유사한 아이디어 

527
00:39:24,920 --> 00:39:26,750
 업데이트 패키지를 패키지 

528
00:39:26,750 --> 00:39:29,650
 그것은 아주 사용하기 매우 쉽습니다 

529
00:39:29,650 --> 00:39:34,079
 이 종류의 나는 매우 유용한 몇 가지 패키지 단지 목록입니다 

530
00:39:34,079 --> 00:39:38,349
 이름으로이 취소 할 수 있도록 성화는 5 파일을 읽고 HDR 쓸 수 있습니다 

531
00:39:38,349 --> 00:39:44,640
 당신은 인 트위터 autorad에서이 재미 하나가 거기에 읽기 및 JSON을 쓸 수 있습니다 

532
00:39:44,639 --> 00:39:47,980
 조금하지만 사용하지 않은 얘기 할 동물처럼 조금 

533
00:39:47,980 --> 00:39:52,369
 하지만 가지를보고 멋진 실제로 페이스 북은 꽤 유용이 

534
00:39:52,369 --> 00:39:57,849
 횃불에 대한 라이브러리는 또한 오십 회선과를 구현하면서 

535
00:39:57,849 --> 00:40:01,548
 데이터 병렬 모델 병렬 처리를 구현 

536
00:40:01,548 --> 00:40:07,449
 그래서 그 횃불에 이렇게 아주 일반적인 워크 플로우가 꽤 꽤 좋은 일이 

537
00:40:07,449 --> 00:40:11,239
 당신이 있습니다 종종 몇 가지 전처리 스크립트를 가지고 그 피칸 것이다 

538
00:40:11,239 --> 00:40:15,818
 전처리 데이터와는 일반적으로 책상 HDL 5에 몇 가지 좋은 형식으로 그것을 덤프 

539
00:40:15,818 --> 00:40:20,528
 큰 일 제이슨 작은 것들에 대해 당신은 내가 일반적으로 쓰기 것이다 것 

540
00:40:20,528 --> 00:40:25,318
 최대 낮은에서 훈련에있는 모든 HDL 5에서 읽고 모델을 학습하고 최적화 

541
00:40:25,318 --> 00:40:30,088
 모델과는 체크 포인트에게 책상을 저장하고 일반적으로 좀 평가가 

542
00:40:30,088 --> 00:40:35,019
 기차 모델을로드하고 그래서 뭔가 유용한 경우 그것을하지 스크립트 

543
00:40:35,019 --> 00:40:39,000
 워크 플로우의이 유형에 대한 연구는 내가 일주일 전에 GitHub의에 올려이 프로젝트 

544
00:40:39,000 --> 00:40:43,969
 즉 문자 수준의 언어 모델과 토치 그래서 여기에 거기를 구현 

545
00:40:43,969 --> 00:40:48,239
 HTML 5에 텍스트 파일을 변환 전처리 스크립트는 거기에 파일을 

546
00:40:48,239 --> 00:40:52,889
 HTML5에 대한로드하고이 재발 네트워크와 열차 훈련 스크립트 

547
00:40:52,889 --> 00:40:57,190
 그건 있도록 검사 점은 세금이 생성 최대로드 샘플링 스크립트가있다 

548
00:40:57,190 --> 00:41:03,720
 즉, 빠른 장점과 단점 나는 나의 일반적인 워크 플로우 및 토치와 같은 종류의 

549
00:41:03,719 --> 00:41:07,169
 그 유혹은 사람들을위한 큰 분기점하지만 나는하지 않는 것이 고문에 대해 말할 것입니다 

550
00:41:07,170 --> 00:41:11,690
 큰 거래는 확실히 덜 플러그가 있다고 실제로 생각하고 그래서 카페에서 재생 

551
00:41:11,690 --> 00:41:15,760
 당신은 아마 조금 전형적으로 자신의 코드를 많이 작성하게 될 겁니다 

552
00:41:15,760 --> 00:41:20,028
 또한 더 많은 오버 헤드하지만 비트는 당신이 모듈을 많이 가지고 더 많은 유연성을 제공 

553
00:41:20,028 --> 00:41:24,278
 플러그 앤 플레이하기 쉽고 조각 표준 라이브러리처럼 

554
00:41:24,278 --> 00:41:26,880
 이 모든 푸른로 작성하기 때문에 읽기가 매우 간단하고 아주 쉽게 

555
00:41:26,880 --> 00:41:31,740
 아주 좋은 초반 이었죠 모델이 많이있어 이해하지만, 

556
00:41:31,739 --> 00:41:34,598
 불행하게도 그것의 재발 네트워크를 사용하는 것이 조금 어색입니다 

557
00:41:34,599 --> 00:41:38,640
 일반 그래서 당신은 당신이 여러 개의 모듈을하고자 할 때 한 달 가지고 싶어 할 때 

558
00:41:38,639 --> 00:41:42,028
 서로 공유하는 가중치는 실제로이와 횃불을 할 수 있지만입니다 

559
00:41:42,028 --> 00:41:42,469
 그것은 종류의 

560
00:41:42,469 --> 00:41:47,199
 취성 그 아마의 그, 그래서 당신은 거기에 미묘한 버그로 실행할 수 있습니다 

561
00:41:47,199 --> 00:41:49,649
 가장주의해야 할 점은 재발 네트워크가 까다로운 일이 될 수 있다는 것입니다 

562
00:41:49,650 --> 00:42:15,800
 어떤 어떤 토치에 대한 질문이 그래 그래하지만 질문에서이 아니다 

563
00:42:15,800 --> 00:42:21,570
 그, 그래서 네 루프와 피칸를 잘 해석하는 방법 나쁜 방법에 대해이었다 

564
00:42:21,570 --> 00:42:24,359
 즉, 해석 있기 때문에이 파이썬에서 정말 나쁜 이유에 대해 정말 

565
00:42:24,358 --> 00:42:27,139
 실제로 메모리 할당과 다른 꽤 많은 일 루푸스에 대한 모든 

566
00:42:27,139 --> 00:42:31,960
 무대 뒤에서 일하지만 만약 당신이 자바 스크립트를 사용 한 경우 다음 루프와 

567
00:42:31,960 --> 00:42:35,059
 자바 스크립트는 꽤 빨리하는 경향이 있기 때문에 런타임 실제로 단지 

568
00:42:35,059 --> 00:42:39,759
 자바 스크립트에서 루프 그래서 네이티브 코드까지 즉석에서 코드를 컴파일 

569
00:42:39,760 --> 00:42:44,520
 정말 빠르고 유체 및 루 실제로 어디 정렬거야 유사한 메커니즘을 가지고 

570
00:42:44,519 --> 00:42:49,588
 인간의 유전자 코드의 자동 마술 컴파일 된 코드 입술 때문에 

571
00:42:49,588 --> 00:42:53,608
 정말 빨리하지만 난 여전히 사용자 지정 벡터화 코드를 쓰고 있다고 할 수 있습니다 

572
00:42:53,608 --> 00:43:01,619
 우리가 가진 모든 권한을 당신에게 속도 업을 많이주고 지금 아마 반 시간은 왼쪽 

573
00:43:01,619 --> 00:43:06,420
 아니 우리가 그래서 옆에 시간이 부족하고, 그래서 두 개 더 프레임 워크를 커버 

574
00:43:06,420 --> 00:43:12,000
 내가 아는 같은 건 몬트리올 대학에서 여호수아 밴조 그룹에서이며, 

575
00:43:12,000 --> 00:43:16,250
 우리는 그래프 innn 조금을 보았다 그래서 계산 그래프에 대해 정말 전부 

576
00:43:16,250 --> 00:43:19,559
 토치에서 그 계산 공예 함께 스티치이 꽤 좋은 방법입니다 

577
00:43:19,559 --> 00:43:24,139
 큰 복잡한 아키텍처와 Fionna 정말 계산이 아이디어에 소요 

578
00:43:24,139 --> 00:43:29,409
 그래픽 및 실행 그것 극단적하고 또한 약간 높은 수준의 라이브러리를 갖는다 

579
00:43:29,409 --> 00:43:33,940
 여기에 같은 계산이 그래서 부족뿐만 아니라에 터치합니다 라자냐입니다 

580
00:43:33,940 --> 00:43:38,570
 우리가 전에 그래프의 맥락에서 본 공예 우리는 실제로 통해 걸을 수 

581
00:43:38,570 --> 00:43:43,400
 2010 년이의 구현은 그래서 당신은 여기에 우리가 가져 오는 것을 볼 수 있습니다 

582
00:43:43,400 --> 00:43:49,440
 fiato과 fiato의 tenser 객체와 지금 여기에 우리가 같이 XY 및 Z를 정의하고 

583
00:43:49,440 --> 00:43:53,099
 이 실제로 말과 매우 유사 기호와 같은 기호 변수 

584
00:43:53,099 --> 00:43:55,530
 그래프의 예를 우리는 불과 몇 슬라이드 전에 보았다 

585
00:43:55,530 --> 00:43:59,500
 이 실제로되도록하는 것은 이러한 종류의 상징적 인 개체 인상 NumPy와하지 

586
00:43:59,500 --> 00:44:05,690
 계산 잔디에서 다음 우리가 할 수 실제로 컴퓨터 이러한 출력에 

587
00:44:05,690 --> 00:44:11,679
 XY 및 Z는이 상징적 인 일이며 우리는 AB & C를 계산할 수 있습니다 상징적 있도록 

588
00:44:11,679 --> 00:44:15,769
 바로 이러한 오버로드 된 연산자를 사용하고이를 구축 할 수 있습니다 

589
00:44:15,769 --> 00:44:19,929
 우리가 구축 한 후, 일단 백그라운드에서 계산 그래프 우리 

590
00:44:19,929 --> 00:44:23,839
 계산 공예 우리는 사실에 그것의 특정 부분을 실행할 수 있도록하려면 

591
00:44:23,840 --> 00:44:29,240
 실제 데이터는 그래서 우리는 그래서이 약 말하고있는이 양극 이상한 함수 일 전화 

592
00:44:29,239 --> 00:44:33,269
 우리는 입력 XY 및 Z를 취할 것입니다 우리의 기능을 할 그것을 생산합니다 

593
00:44:33,269 --> 00:44:38,329
 출력이 우리가 평가할 수있는 실제 파이썬 함수를 반환합니다 참조 

594
00:44:38,329 --> 00:44:42,239
 실제 데이터와 나는이 정말 지적하고 싶은 경우 모든 마법과 

595
00:44:42,239 --> 00:44:46,319
 Fionna 당신이 함수를 호출 할 때 미친 미친 일을 할 수 있다는 일어나고 

596
00:44:46,320 --> 00:44:49,580
 물건은 그것이 더 확인하기 위해 계산 그래프를 단순화 할 수 있습니다 

597
00:44:49,579 --> 00:44:54,199
 효율적인 실제로 상징적 내가 가식과 다른 것들과 산기 수 있습니다 

598
00:44:54,199 --> 00:44:58,319
 당신이 그것을 연결하는 함수를 호출 할 때 실제로 그렇게 네이티브 코드를 생성 할 수 있습니다 

599
00:44:58,320 --> 00:45:02,450
 실제로 때로는 항공편에서 코드를 컴파일 때문에 GPU에 비공식적 있습니다 

600
00:45:02,449 --> 00:45:06,389
 모든 마법과 Fiano 정말이 작은 죄에서이오고있다 

601
00:45:06,389 --> 00:45:11,750
 파이썬에서 문을 찾고 있지만 여기에 후드 일이 많이있다 및 

602
00:45:11,750 --> 00:45:14,710
 지금 한 번 우리는이 미친 물건을 통해이 마법의 기능을 쪘 

603
00:45:14,710 --> 00:45:19,159
 우리는 단지 우리가 인스턴스화 그래서 여기 인상보다 실제 수에서 실행할 수 있습니다 

604
00:45:19,159 --> 00:45:25,440
 xxyyxx 실제 수보다 높은 등급으로 실제 쉽고 그 다음 우리는 막을 수 

605
00:45:25,440 --> 00:45:30,639
 이러한 실제 번호를 전달하는 우리의 기능은 이것을 값을 얻을 수 있습니다 

606
00:45:30,639 --> 00:45:35,359
 파이썬에서 폭발적으로 이러한 계산을하고 같은 일을하고있다 

607
00:45:35,360 --> 00:45:39,289
 것을 제외하고 최종 버전으로 인해 모든 마법에 훨씬 더 효율적이 될 수 

608
00:45:39,289 --> 00:45:42,840
 후드와 피아노 버전에서 실제로 GPU 경우에 실행 될 수있다 

609
00:45:42,840 --> 00:45:47,289
 당신은 구성하지 않은 그러나 불행하게도 우리가 정말 걱정하지 않는다 

610
00:45:47,289 --> 00:45:51,659
 우리가 여기 먹으 렴 알고 싶어이 같은 일을 계산하는 것은의 예 

611
00:45:51,659 --> 00:45:57,629
 (10)에서 간단한 도구 공기 풍선 그래서 아이디어는 우리가 가고있는이 동일하다 

612
00:45:57,630 --> 00:46:02,860
 우리의 입력을 선언하지만 지금은 대신 그냥 XY 및 Z 우리가 우리의 입력 구문 

613
00:46:02,860 --> 00:46:06,490
 더 나은 우리의 라벨 및 Y 

614
00:46:06,489 --> 00:46:11,009
 행렬 W & W 너무 그래서 우리는 그저 설정하는이 상징적 인 체중한다 

615
00:46:11,010 --> 00:46:17,540
 변수는 우리의 계산 잔디의 요소가 될 것이다 지금 44 패스 우리를 

616
00:46:17,539 --> 00:46:21,179
 좀 NumPy와 같습니다하지만 기호에없는 기괴한 작업이다 

617
00:46:21,179 --> 00:46:24,669
 그래서 여기 백그라운드에서 그래프를 구축 계산되는 개체 

618
00:46:24,670 --> 00:46:28,909
 이과 활성화. 방법 행렬 곱셈하지만 우리는 상징적 필요가 

619
00:46:28,909 --> 00:46:33,210
 개체는 우리는이 라이브러리 함수를 사용하여 실제 문제를하고있는 우리는있어 

620
00:46:33,210 --> 00:46:37,769
 또 다른 행렬의 곱셈을하고 우리는 실제로 손실을 계산할 수 있습니다 

621
00:46:37,769 --> 00:46:41,210
 다시 이러한 몇 가지 다른 라이브러리 기능을 이용하여 확률과 로스 

622
00:46:41,210 --> 00:46:44,349
 까지 구축하고 상징적 인 개체에 대한 모든 작업은 

623
00:46:44,349 --> 00:46:50,420
 우리는 우리의 기능 때문에이 기능을 컴파일 할 수 있도록 전산 잔디 

624
00:46:50,420 --> 00:46:54,570
 걸릴 것입니다 우리의 데이터는 레이블이며, 행렬을 가중하는 우리의 28 요소는 

625
00:46:54,570 --> 00:46:58,890
 및 풋 출력으로 나는 손실과 스칼라 우리를 반환합니다 

626
00:46:58,889 --> 00:47:04,109
 분류 점수 벡터에서 지금 우리가 실제 데이터에이 일을 실행할 수 있습니다 

627
00:47:04,110 --> 00:47:07,559
 우리는 이전 슬라이드에서 본 것처럼 우리는 몇 가지 실제 수의 I를 인스턴스화 할 수 

628
00:47:07,559 --> 00:47:13,759
 함수에 제기하고 전달 그래서 이것은 큰하지만 이것은 단지입니다 

629
00:47:13,760 --> 00:47:17,820
 네 번째는 실제로 그렇게이 네트워크 및 컴퓨터 생기를 양성 할 수 있도록 

630
00:47:17,820 --> 00:47:23,000
 여기에 우리가 너무이 동일하다고 할 코드의 몇 라인을 추가 할 필요가 

631
00:47:23,000 --> 00:47:27,170
 우리는 우리가 정의하고있어 이전과 같이 우리의 입에 대한 상징적 인 변수는 

632
00:47:27,170 --> 00:47:29,510
 우리의 무게 등 우리는 함께있어 

633
00:47:29,510 --> 00:47:33,980
 전에 같은 4 패스를 실행하는 컴퓨터의 법률에 손실을 계산하기 

634
00:47:33,980 --> 00:47:37,920
 상징적으로 차이가 우리가 실제로 할 수있는 알고 

635
00:47:37,920 --> 00:47:43,680
 여기에 상징적 인 차별화 그래서이에 우리가 내가 말하는 거 야 디 W 하나 TW입니다 

636
00:47:43,679 --> 00:47:47,129
 우리가 그는 손실의 성분의 기울기가되고 싶어요 것을 알고있다 

637
00:47:47,130 --> 00:47:52,280
 그래서이 두 개의 W 하나의 최소 W 그 다른 상징적 인 변수에 대하여 

638
00:47:52,280 --> 00:47:52,930
 정말 멋진 

639
00:47:52,929 --> 00:47:56,549
 fiato는 그래프의 어떤 부분에 임의의 그라데이션을 할 수 있습니다 

640
00:47:56,550 --> 00:48:00,289
 그래프의 다른 부분에 대한 새로운으로 그 도입 도입하지 

641
00:48:00,289 --> 00:48:05,190
 그래프의 기호 변수는 당신이 정말로 그와 함께 미친 갈 수 있도록하지만, 

642
00:48:05,190 --> 00:48:09,470
 여기이 경우 우리는 지금 출력으로 그 캐나다인을 반환거야 

643
00:48:09,469 --> 00:48:14,049
 우리는 다시 새로운 기능을 컴파일거야 우리의 입력이 걸릴 것입니다 

644
00:48:14,050 --> 00:48:19,510
 입력 입력 픽셀 자루와 우리의 레이블 왜 28 행렬과 함께 

645
00:48:19,510 --> 00:48:23,140
 지금은 우리의 손실을 반환 할 것 이러한 분류 점수와 

646
00:48:23,139 --> 00:48:28,250
 지금 우리는 실제로 매우 간단한 훈련이 설정을 사용할 수있는 두 가지 성분 있도록 

647
00:48:28,250 --> 00:48:32,809
 신경 네트워크는 그래​​서 우리는 실제로 단지 그라데이션을 구현 그라데이션 하강을 사용할 수 있습니다 

648
00:48:32,809 --> 00:48:36,630
 이 계산을 사용하여이이를 이용하여 단지 몇 줄의 하강 

649
00:48:36,630 --> 00:48:38,990
 그래서 여기에 우리가있어 잔디 

650
00:48:38,989 --> 00:48:43,599
 데이터 세트 및 요인에 대한 인상보다 실제 수를 인스턴스화 

651
00:48:43,599 --> 00:48:45,489
 로 다시 어떤 임의의 행렬 

652
00:48:45,489 --> 00:48:49,839
 실제 수는 더 높은 올릴 때 우리는 지금 우리가이 전화를 걸 때마다 물어 

653
00:48:49,840 --> 00:48:50,519
 돌아 가야 

654
00:48:50,519 --> 00:48:54,710
 NumPy와 배열은 지금 우리가 그 손실 및 점수와 그라데이션을 포함한다 

655
00:48:54,710 --> 00:48:57,800
 그라디언트를 우리는 단지 간단한 그라데이션 업데이트를 우리의 가중치에 만들 수 있습니다 

656
00:48:57,800 --> 00:49:01,970
 및 조치는 우리의 네트워크를 훈련 골목 - OOP를 약속하지만 실제로있다 

657
00:49:01,969 --> 00:49:06,039
 이 문제의 큰 당신이 할 수있는 GPU를 누군가에 실행중인 특히 

658
00:49:06,039 --> 00:49:15,599
 완전히 문제를 손실 할 사람이 실제로 많이 초래된다는 것이다 

659
00:49:15,599 --> 00:49:21,059
 CPU와 GPU 사이의 통신 오버 헤드를 통해 때문에 우리가 우리 때마다 

660
00:49:21,059 --> 00:49:24,799
 기능이 전화 그리고 우리는 복사 먹으 렴 다시이 그라디언트를 얻을 수 

661
00:49:24,800 --> 00:49:29,720
 다시 CPU에 GPU에서 그라디언트 나는 비용이 많이 드는 작업 할 수 있고, 

662
00:49:29,719 --> 00:49:35,000
 이제 우리는 실제로 우리의 그라데이션 중지 만들고있어이 너무 NumPy와의 CPU 계산이다 

663
00:49:35,000 --> 00:49:38,190
 우리가 그 기울기 업데이트를 우리의 매개 변수를 할 수 있도록 할 수 있다면 정말 좋을 텐데 

664
00:49:38,190 --> 00:49:45,389
 실제로 직접 GPU 길에 우리가 그 Fiano이 함께 있음 

665
00:49:45,389 --> 00:49:50,619
 공유 변수라고이 학교 일에 그래서 변수가 다른 것입니다 공유 

666
00:49:50,619 --> 00:49:54,230
 네트워크 실제로 일부는 내부 연산 사는 값 

667
00:49:54,230 --> 00:49:59,340
 공예 실제로이 실제로이 그래서 여기에 전화 통화에서 지속 

668
00:49:59,340 --> 00:50:04,150
 매우 유사 이제 정의 된 우리 같은 상징적 인 변수 X & Y 전 

669
00:50:04,150 --> 00:50:08,769
 데이터와 라벨과 지금 우리가 새로운 펑키의 몇 가지를 정의하고 대한 

670
00:50:08,769 --> 00:50:13,809
 행렬 및 초기화를 가중하는 우리를위한 것 펑키 공유 변수를 

671
00:50:13,809 --> 00:50:19,110
 NumPy와 이러한 가중치 행렬을 제기하고 지금이 이전과 동일 

672
00:50:19,110 --> 00:50:22,910
 이들을 사용하여 포워드 패스를 산출 여기서 이전과 동일한 코드이다 

673
00:50:22,909 --> 00:50:24,980
 라이브러리 함수는 상징적이다 

674
00:50:24,980 --> 00:50:30,940
 그라디언트 그러나 우리는 지금이 그래서 우리의 함수를 정의하는 방법을 지금의 차이에 

675
00:50:30,940 --> 00:50:32,269
 컴파일 기능 

676
00:50:32,269 --> 00:50:36,780
 만 가중치를 수신하지 않는 수신하고 그 실제로 살고 둔다 

677
00:50:36,780 --> 00:50:41,320
 연산 그래프 내부 대신 우리는 단지 데이터 및 상기 수신 데이터 

678
00:50:41,320 --> 00:50:45,210
 그리고 라벨과 지금 우리는 출력보다 오히려 손실을 넣어 가고있다 

679
00:50:45,210 --> 00:50:49,639
 성분은 명시 적으로 대신 우리가 실제로 이러한 업데이트 규칙을 제공하는 그들 

680
00:50:49,639 --> 00:50:53,819
 이 업데이트 규칙을 알 수 있도록 함수가 호출 될 때마다 실행해야 우리 

681
00:50:53,820 --> 00:50:57,920
 이 그냥 그래서 상징적 인 변수에서 작동 작은 기능 

682
00:50:57,920 --> 00:51:02,010
 우리는 그가 산타를 만드는 것해야한다는 것은 하나의 최소 W W 업데이트 할 중지 

683
00:51:02,010 --> 00:51:09,290
 이 우리가이 계산 그래프를 실행할 때마다 그래서 지금 매주 업데이트 및 기록 

684
00:51:09,289 --> 00:51:12,880
 우리가해야 할 모든 반복마다이 함수를 호출 인이 네트워크를 훈련 

685
00:51:12,880 --> 00:51:16,869
 우리가 함수를 호출 할 때 사람들은 그렇게의 방법에 그라데이션 중지 할 것 

686
00:51:16,869 --> 00:51:21,210
 우리는 그냥 반복해서 그냥이 일을 호출하여이 네트워크를 시도 할 수 있습니다 

687
00:51:21,210 --> 00:51:23,769
 당신이 이런 종류의 일을 할 때 할 때 연습하고 난 당신거야 알고 

688
00:51:23,769 --> 00:51:27,579
 종종 다음 무게를 업데이트하고 우리의 교육 함수 호출을 정의 

689
00:51:27,579 --> 00:51:31,719
 난 그냥 점수를 넣어 당신이 할 수있는 업데이트를하지거야 기능을 평가 

690
00:51:31,719 --> 00:51:34,609
 실제로이 컴파일 된 함수의 여러에 대한 8 개의 다른 것이있다 

691
00:51:34,610 --> 00:51:47,220
 같은 그래프의 부분은 그래 그래 문제는 우리가 기울기를 계산하는 방법이다 

692
00:51:47,219 --> 00:51:51,119
 그것은 실제로는 그렇지 않아 잘은 상징적 종류의 사람이 밖으로에게 S 않습니다 

693
00:51:51,119 --> 00:51:55,219
 때마다 당신이이 통화를 할 수 있기 때문에 실제로 성에서 사람이의 일종이다 

694
00:51:55,219 --> 00:51:58,769
 그래픽 객체에이 계산을 구축하고 당신은 계산할 수 있습니다 

695
00:51:58,769 --> 00:52:06,090
 단지 그래픽의 계산에 노드를 추가하여 그라디언트 그래서 개체 그래 

696
00:52:06,090 --> 00:52:09,360
 그래, 그래서 그것이 무엇을 알고 이러한 기본 운영자의 각을 알 필요가 

697
00:52:09,360 --> 00:52:12,500
 파생 상품과 파생 및이 여전히 정상 정상 

698
00:52:12,500 --> 00:52:17,309
 당신이 그것을 볼 것을 다시 전파는 작동하지만 그 중 일부하지만 피치 

699
00:52:17,309 --> 00:52:21,299
 내가 아는 그것이 작동하고 그는 매우 매우 낮은 수준의 기본 작업입니다 

700
00:52:21,300 --> 00:52:24,920
 이러한 요소의 사물과 행렬 곱셈으로하고 바라고 때처럼 

701
00:52:24,920 --> 00:52:27,800
 이 효율적인 코드를 컴파일 할 수있는 사람들을 통합하고 단순화 

702
00:52:27,800 --> 00:52:32,210
 상징적으로 내가 어떻게 작동하는지 잘 모르겠어요하지만 적어도 무슨하다고 

703
00:52:32,210 --> 00:52:37,110
 그들은 그렇게 다른 고급 많은 것들을 많이 거기에 이렇게 주장하는 당신 

704
00:52:37,110 --> 00:52:40,309
 무엇이든 할 수 나는 우리가 당신이 할 수있는 얘기 할 시간이없는 것을 알고있다 

705
00:52:40,309 --> 00:52:43,610
 실제로 사용하여 경쟁 공예 내부에 직접 조건문은 다음과 같습니다 

706
00:52:43,610 --> 00:52:44,809
 이 파일 

707
00:52:44,809 --> 00:52:49,029
 그리고 스위치는 당신이 실제로 루프를 내부자 계산을 포함 할 수 있습니다 명령 

708
00:52:49,030 --> 00:52:52,370
 그래프이 정말 이해하지 못하는이 재미 스캔 기능을 사용하여 

709
00:52:52,369 --> 00:52:57,409
 하지만 힘든하지만 이론적으로는 매우 재발 네트워크를 구현할 수 있습니다 

710
00:52:57,409 --> 00:53:01,909
 쉽게 당신이 잠시 상상할 수있는 다음 중 하나의 작업에서 발생하는 

711
00:53:01,909 --> 00:53:05,539
 계산 공예가에 동일한 가중치 행렬을 통과하고있는 모든 

712
00:53:05,539 --> 00:53:10,110
 여러 노드 및 정렬 할 그 루프 및이 수 실제로 검사 

713
00:53:10,110 --> 00:53:14,680
 루프는 그래프의 명시 적 부분의 일부와 우리가 실제로 미친 갈 수 있습니다 

714
00:53:14,679 --> 00:53:17,909
 파생 상품과 우리는 밖으로 어떤과 ​​관련하여 파생 상품을 계산할 수 있습니다 

715
00:53:17,909 --> 00:53:21,149
 우리는 또한 자코비 계산할 수있는 다른 부분에 대한 선박의 일부 

716
00:53:21,150 --> 00:53:24,300
 파생 상품 우리는 알렌을 사용할 수의 파생 상품을 계산하여 종료 우리 

717
00:53:24,300 --> 00:53:29,140
 운영자는 공식적으로 배우로서 큰 주요 행렬 - 벡터 곱셈을 만든하려면 

718
00:53:29,139 --> 00:53:32,500
 와 자코비 존스 당신은 정말 멋진 다른 파생 테이크를 많이 할 수 

719
00:53:32,500 --> 00:53:36,610
 아마 상단과 다른 프레임 워크 그리고 그것은 또한 일부가 피아노에 재고 

720
00:53:36,610 --> 00:53:40,180
 스파 스 매트릭스에 대한 지원은 즉석에서 코드를 최적화하기 위해 시도 

721
00:53:40,179 --> 00:53:45,669
 내가 아는 다른 멋진 일을하는 것은이 거기에 멀티 GPU 지원을 가지고 

722
00:53:45,670 --> 00:53:50,599
 내가 그 제외한 사용하지 않은 패키지는 데이터 병렬 처리를 얻을 수 있다고 주장 

723
00:53:50,599 --> 00:53:54,500
 그래서 여러 GPU를 통해 분할에 대한 의미와 거기에 배포 

724
00:53:54,500 --> 00:53:57,260
 이 계산에 모델 병렬 처리에 대한 실험 지원 

725
00:53:57,260 --> 00:54:01,320
 그래프는 다른 장치 있지만 문서 사이에 분할됩니다 

726
00:54:01,320 --> 00:54:08,030
 라고 그 실험 아마 정말 실험 그래서, 그래서 당신이 본 있도록 

727
00:54:08,030 --> 00:54:11,730
 작업을 할 때 나는 API가 조금 낮은 수준 인 것을 알고 우리는 필요 

728
00:54:11,730 --> 00:54:15,769
 일종의 해결할은 somos 아냐가 업데이트 규칙과 모든 것을 구현 

729
00:54:15,769 --> 00:54:19,900
 는 I 주변이 높은 수준의 래퍼는 거리의 일부를 추상의 종류를 알고 

730
00:54:19,900 --> 00:54:24,660
 당신을 위해 그 세부 그래서 다시 우리가 일종의 상징적 인 행렬을 정의하고 있고 

731
00:54:24,659 --> 00:54:28,659
 라자냐는 자동으로 설정됩니다 이러한 계층 기능이있는 

732
00:54:28,659 --> 00:54:32,489
 공유 변수와 그런 종류의 물건 우리는의 확률을 계산할 수 있습니다 

733
00:54:32,489 --> 00:54:38,469
 손실 라이브러리에서이 편리한 것을 사용하고, 라자냐 실제로 수 

734
00:54:38,469 --> 00:54:41,969
 우리가 구현하는 이러한 업데이트 규칙과 강한 추진력을 작성하고 

735
00:54:41,969 --> 00:54:47,109
 다른 멋진 것들과 지금 우리가 컴파일 우리의 기능 우리가 실제로 단지 

736
00:54:47,110 --> 00:54:51,390
 내 라자냐와 모두가 우리를 위해 기록 된이 업데이트 규칙에 전달 

737
00:54:51,389 --> 00:54:51,839
 방법 

738
00:54:51,840 --> 00:54:56,309
 객체뿐만 아니라 라자냐가 우리를 위해 찍은 치료의 치료를 찍은 

739
00:54:56,309 --> 00:54:59,579
 다음 날의 끝에서 우리는 이러한 컴파일 피아노 하나 결국 

740
00:54:59,579 --> 00:55:04,599
 기능과 우리는 또 다른 거기에 다른 거기에 이전과 같은 방법으로 사용 

741
00:55:04,599 --> 00:55:10,480
 꽤 인기있는 문화의 래퍼 4390 우리는 조금 짝수되는 

742
00:55:10,480 --> 00:55:15,730
 그래서 여기에 우리가 순차적으로 컨테이너를 만들고 추가하는 데있어 더 높은 수준의 

743
00:55:15,730 --> 00:55:20,559
 그것에 층의 스택은 그래서 이것은 종류의 횃불처럼 이제 우리는이 데있어 

744
00:55:20,559 --> 00:55:25,789
 가는이 상사 개체를 만들기에 실제로 우리를 갱신하고 지금 우리가 할 수있는 

745
00:55:25,789 --> 00:55:29,759
 이 슈퍼 그래서 그냥 방법을 맞는 모델을 사용하여 우리의 네트워크를 훈련 

746
00:55:29,760 --> 00:55:36,570
 높은 수준의 당신은 심지어 피아노를 사용하여 실제로 우리를 수행 할뿐만 아니라 말할 수 없다 

747
00:55:36,570 --> 00:55:40,289
 뿐만 아니라 당신이하지 않아도 배경은 그것으로 영광을 사용하지만 거기하기 

748
00:55:40,289 --> 00:55:44,500
 당신이 당신의 경우 경우 실제로 하나의 큰이 코드 조각 문제와 나도 몰라 

749
00:55:44,500 --> 00:55:49,219
 경험이 나중에 알고 있지만 실제로 충돌 수 있으며, 그것은에 충돌로 

750
00:55:49,219 --> 00:55:54,750
 정말 나쁜 방법은 오류 메시지가 그렇습니다 우리는이 거대한 스택 트레이스 아무 것도 얻을 

751
00:55:54,750 --> 00:55:58,380
 우리가 작성한 코드의 통해 우리는이 거대한 값 오류가 발생하는 

752
00:55:58,380 --> 00:56:03,440
 내가 Fiano 정말 전문가 그래서이 아니에요 그래서 나에게 어떤 의미가 없습니다 

753
00:56:03,440 --> 00:56:07,039
 정말 나에게 혼란되었다 그래서 우리는 간단한 찾고 코팅 처리의이 종류를 썼다 

754
00:56:07,039 --> 00:56:11,259
 우리하지만 팩으로 fiato를 사용하고 그것을 밖으로 허튼과 우리에게 준 때문에 

755
00:56:11,260 --> 00:56:15,030
 즉, 내가 일반적인 통증 포인트 중 하나라고 생각, 그래서 정말 오류 메시지가 혼란 

756
00:56:15,030 --> 00:56:18,730
 디버깅 배경으로 사용 아무것도 실패 사례 수 

757
00:56:18,730 --> 00:56:24,949
 좀 열심히 공기를 봤와 나는 것을 발견 좋은 개발자가 같은 수 

758
00:56:24,949 --> 00:56:28,659
 내가 잘못 흰색 변수의 폭을 포함하고 나는 것을 발견 

759
00:56:28,659 --> 00:56:32,579
 내 아내 변수로 변환이 기타 다른 기능을 사용하는 가정 및 

760
00:56:32,579 --> 00:56:35,690
 문제가 멀리 갈 수 있도록하지만 오류 메시지에서 분명 아니었다 

761
00:56:35,690 --> 00:56:41,139
 그 피아노 피아노를 사용할 때 신경이 쓰이는 것이 좋을 위해 뭔가 

762
00:56:41,139 --> 00:56:44,699
 우리가 라자냐에 대해 이야기 때문에 실제로 초반 이었죠 모델이 

763
00:56:44,699 --> 00:56:48,539
 실제로 꽤 좋은 모델 당신에게 다른 인기있는 모델을 많이 가지고 

764
00:56:48,539 --> 00:56:52,820
 아키텍처는 당신이 그렇게 라자냐 당신이 알렉스와 구글을 사용 할 수도 있다는 것입니다 

765
00:56:52,820 --> 00:56:56,190
 매트와 BG 나는 그들이 아직 주민을 생각하지 않습니다하지만 그들은 꽤 많이있다 

766
00:56:56,190 --> 00:57:00,320
 거기에 유용한 것들과 내가 발견 몇 가지 다른 패키지가 

767
00:57:00,320 --> 00:57:04,550
 분명 정말로 내 말을 제외하고이 명확하게 굉장했다 좋은 것 같다 그것 때문에 

768
00:57:04,550 --> 00:57:07,030
 작년부터 CS2 (31) 및 프로젝트였다 

769
00:57:07,030 --> 00:57:10,330
 당신거야 하나를 선택하면하지만 난 그것이 아마 라자냐 모델을 생각한다 

770
00:57:10,329 --> 00:57:16,139
 내가 아는 가지고 노는 내 하루 경험 그래서 정말 좋은 

771
00:57:16,139 --> 00:57:20,029
 장점과 단점에 대해 나는 곳의 파이프 라인이 심판의 볼 수있는 

772
00:57:20,030 --> 00:57:20,890
 훌륭 해요 

773
00:57:20,889 --> 00:57:23,920
 이 계산 쓰레기 특히 주위에 정말 강력한 아이디어처럼 보인다 

774
00:57:23,920 --> 00:57:28,760
 상징적으로 그라데이션을 계산하고 이러한 모든 최적화 그것은 특히 R과 

775
00:57:28,760 --> 00:57:32,070
 나는이 계산 그래프를 사용하여 구현하는 것이 훨씬 쉬울 것이라고 생각 종료 

776
00:57:32,070 --> 00:57:37,570
 Rottino의 종류 추한 및 총하지만 특히 라자냐는 꽤 좋아 보인다 

777
00:57:37,570 --> 00:57:41,470
 저와 종류의 오류 메시지가 꽤 될 수있는 고통의 일부를 빼앗아 

778
00:57:41,469 --> 00:57:46,279
 내가 무슨 소리를 들었어요에서 우리가 보았 듯이 고통과 큰 모델은 정말 오래 할 수 있습니다 

779
00:57:46,280 --> 00:57:51,190
 컴파일 시간 그래서 그 우리에 대한 즉시 해당 함수를 컴파일 할 때 

780
00:57:51,190 --> 00:57:54,579
 거의 순간적으로 실행되는 모든 간단한 예제하지만 우리는있어 

781
00:57:54,579 --> 00:57:58,159
 내가 이야기를 들었습니다 신경 튜링 기계처럼 큰 복잡한 일을 그 

782
00:57:58,159 --> 00:58:01,969
 즉, 실제로는 아니에요 그건 너무 컴파일 아마 반 시간이 걸릴 수 있습니다 

783
00:58:01,969 --> 00:58:06,239
 좋은 그것은 당신의 모델과 다른 종류에 빠르게 반복에 대한 좋지 않다 

784
00:58:06,239 --> 00:58:10,509
 통증의 포인트는 API가 모든 일을거야 토치보다 훨씬 더 나은 것입니다 

785
00:58:10,510 --> 00:58:13,470
 그것은 이해하기 힘든 종류, 그래서 배경이 복잡한 물건과 

786
00:58:13,469 --> 00:58:17,969
 디버그하지만, 실제로 코드를 발생하고 초반 이었죠 모델은 어쩌면이다 

787
00:58:17,969 --> 00:58:22,569
 라자냐는 꽤 좋은처럼되지 확실히 카페 또는 토치 좋은 그러나 그것은 본다 

788
00:58:22,570 --> 00:58:30,320
 확인은 그래서 우리는 첫 번째 경우 비록 1000을 얘기 십오분 지금있어 

789
00:58:30,320 --> 00:58:38,309
 내가 시도 할 수 있습니다 알고는 확인이 그렇게 tenser 흐름이 아니다에 대한 질문이있다 

790
00:58:38,309 --> 00:58:42,809
 센서는 정말 시원하고 반짝 새롭고의 Google에서 모든 사람의 흐름 

791
00:58:42,809 --> 00:58:47,829
 그것에 대해 흥분하고 실제로 많은 방법에서 피오나와 매우 유사 그 

792
00:58:47,829 --> 00:58:51,170
 그들은 정말 계산 그래프의이 아이디어와 건물을 복용하고 

793
00:58:51,170 --> 00:58:55,650
 그는 모든 것을 tenser 흐름과 Fiano 실제로 아주 아주 밀접하게 연결되도록 

794
00:58:55,650 --> 00:58:59,090
 내 마음에 그 중 하나를 사용하여 멀리 얻을 수있는 종류의 해리스 등이다 

795
00:58:59,090 --> 00:59:04,760
 하나는 백핸드이며, 또한 어떤 하나의 어쩌면 약 1000인지 확인 가리 

796
00:59:04,760 --> 00:59:07,200
 그것은에서 설계된 이러한 프레임 워크 중 제 1의 일종 

797
00:59:07,199 --> 00:59:10,750
 전문 엔지니어에 의해 접지 

798
00:59:10,750 --> 00:59:14,000
 그래서 다른 프레임 워크의 많은 종류의 학술 연구 실험실에서 회전 및 

799
00:59:14,000 --> 00:59:17,320
 그들은 정말 좋은있어, 그들은 당신이 정말 잘 일을 할 수 있도록하지만 그들은 일종의했다 

800
00:59:17,320 --> 00:59:23,120
 토치 특히 의해 관리되고, 특히 있도록 대학원 학생들에 의해 유지 

801
00:59:23,119 --> 00:59:26,500
 지금 트위터와 페이스 북에서 일부 엔지니어하지만 원래 학술했다 

802
00:59:26,500 --> 00:59:30,070
 프로젝트 및 이들의 모든 나는 tenser 흐름이었다 첫 번째 생각 

803
00:59:30,070 --> 00:59:35,000
 그래서 아마 이론적으로 산업 곳에서 목에서 처음부터 

804
00:59:35,000 --> 00:59:37,989
 그없이 내가 그나마 나은 코드 품질이나 시험 범위 또는 무언가로 이어질 수 

805
00:59:37,989 --> 01:00:04,519
 나는 확실하지 그래서 여기에 꽤 무서운 듯 우리 마음에 드는 사람이 누워있어 여기 그래서 해요 

806
01:00:04,519 --> 01:00:07,389
 우리는거야 라빈 우리는 그것을했고, 다른 모든 프레임 워크는 의도의이하자 

807
01:00:07,389 --> 01:00:12,769
 그래서 우리가 걸 볼 수 있도록이 실제로 알고있는 나는 정말 비슷합니다 흐름 

808
01:00:12,769 --> 01:00:17,320
 Fiano에 tenser 흐름을 가져 우리가이 행렬과 벡터를 기억 

809
01:00:17,320 --> 01:00:21,019
 기호 변수 강렬한 워크로드 그들은 자리라고하고 있지만입니다 

810
01:00:21,019 --> 01:00:26,380
 이 같은 생각은 우리가있어 우리의 계산 그래프에 입력 노드를 작성하는 

811
01:00:26,380 --> 01:00:30,650
 또한 fiato에 무게 행렬을 정의하는 것 우리는 이러한 공유 일이 

812
01:00:30,650 --> 01:00:34,490
 그라는 계산 그래프 같은 생각하고 유연한 텐서 안에 살았다 

813
01:00:34,489 --> 01:00:40,359
 변수를 우리가 같은 단지 계산 Ciano처럼 사용하여 통과 기대된다 

814
01:00:40,360 --> 01:00:44,610
 작동이 라이브러리 방법은이 일에 상징적에 작동 

815
01:00:44,610 --> 01:00:48,289
 즉, 쉽게를 계산 할 수 있도록 전산 그래프를 구축 

816
01:00:48,289 --> 01:00:52,210
 확률은 상징적으로이 같은 손실과 모든에 

817
01:00:52,210 --> 01:00:56,190
 실제로 나는 나보다는 조금 더 우리에게 보이는 관심이 더 많은 것 같습니다에 생각 

818
01:00:56,190 --> 01:01:00,740
 바위보다 회전 목마 라자냐처럼 알고 있지만, 우리는이 경사 하강을 사용하는 

819
01:01:00,739 --> 01:01:04,669
 최적화는 그리고 우리는 그래서 여기에 우리가하지 않은 손실을 최소화하기 위해 그것을 말하는 거 

820
01:01:04,670 --> 01:01:08,970
 명시 적으로하지만, 그라디언트를 토하고 우리는 명시 적으로 대해 서면으로하지 않는 

821
01:01:08,969 --> 01:01:13,489
 무역 업데이트 규칙 대신이 사람들의 일을 사용하지만 그냥 일종의 추가되었다 

822
01:01:13,489 --> 01:01:19,250
 그냥 지금 손실을 최소화하기 위해 그래프로 할 필요가 무엇이든 

823
01:01:19,250 --> 01:01:23,059
 같은 Ciano 시장에서 우리가 실제로 더 높은 실제 번호를 사용하여 인스턴스화 할 수 

824
01:01:23,059 --> 01:01:23,779
 증가 

825
01:01:23,780 --> 01:01:29,470
 일부 몇 가지 작은 데이터 세트 후 우리는 루프 너무 강한 공기 흐름에서 실행할 수 있으며, 

826
01:01:29,469 --> 01:01:33,750
 당신은 실제로 당신이 그것을 포장 할 필요가 사용해야하는 코드를 실행하려면 

827
01:01:33,750 --> 01:01:39,199
 세션 코드는 내가 무엇을하고 있는지 이해가 안하지만 그건 당신이 실제로 그것을 할 수 있었다 

828
01:01:39,199 --> 01:01:42,599
 실제로 무엇을하고있어하면 그 모든 정거장 짧은하지만 할 갔다 

829
01:01:42,599 --> 01:01:45,869
 당신의 계산 잔디를 설정하고 놓친 세션이 실제로하고있다 

830
01:01:45,869 --> 01:01:48,440
 어떤 최적화 실제로 실행하고자 할 필요가 

831
01:01:48,440 --> 01:01:58,110
 그래 그래서 당신이 있다면 그래서 질문은 당신이 기억 그래서 만약 하나의 뜨거운 무엇인가 

832
01:01:58,110 --> 01:02:01,840
 과제는 부드러운 최대 손실 함수처럼했지만 왜 때 

833
01:02:01,840 --> 01:02:06,170
 항상 정수는 당신이 원하는하지만 어떤 일을 말하는 이들 중 일부에 

834
01:02:06,170 --> 01:02:11,420
 모든 곳에 대신 정수의 프레임 워크는 요인이 될한다 

835
01:02:11,420 --> 01:02:15,090
 즉 실제로이었을 정도로 신용 클래스가 있던 일을 제외하고 제로 

836
01:02:15,090 --> 01:02:20,420
 에 나를 넘어 버그는 차이가 뜨거운 일 사이에 있었다 다시 우리를 걱정 

837
01:02:20,420 --> 01:02:28,710
 뜨거운 그것은 10 2011 핫 어떤 권리를 밝혀없는 것보다 우리 때 

838
01:02:28,710 --> 01:02:34,250
 실제로 우리가 실제로 기억하고 우리가 fiato에 전화 한 후이 네트워크를 훈련 할 

839
01:02:34,250 --> 01:02:37,610
 이 함수 객체를 컴파일 한 다음 또 다시 함수를 호출 

840
01:02:37,610 --> 01:02:41,940
 해당 강한 공기 흐름은 우리가의 run 메소드를 호출하는 데 사용한다는 것입니다 

841
01:02:41,940 --> 01:02:46,409
 세션 객체 우리는 우리가 계산하는 원한 스위치 출력을 말해 

842
01:02:46,409 --> 01:02:50,349
 여기에서 우리는 우리가 기차가 내가이야 무엇을 중단 계산 할 것인지를 말하는 거 

843
01:02:50,349 --> 01:02:54,769
 라 셀리 퍼트 우리는 이러한 입력에 발생이 NumPy와에 거 피드있어 그렇게 

844
01:02:54,769 --> 01:02:57,699
 우리가 run 메소드를 호출하는 것을 제외하고이 디아 노 같은 아이디어의 종류 

845
01:02:57,699 --> 01:03:02,210
 오히려 명시 함수를 컴파일 컴파일보다 과정에서 

846
01:03:02,210 --> 01:03:06,179
 이 열차 정지 객체 선거을 평가에 그라데이션 하강을 

847
01:03:06,179 --> 01:03:10,690
 무게는 그래서 우리는 단지 루프에서이 일을 실행하고 로스가 다운 될 수 있습니다 

848
01:03:10,690 --> 01:03:16,450
 모든 것이 tenser 흐름에 대한 정말 멋진 것들 중 하나 아름답습니다 그래서 

849
01:03:16,449 --> 01:03:20,519
 쉽게 쉽게 무엇을 시각화 할 수 있습니다 tenser 보드라는이 일입니다 

850
01:03:20,519 --> 01:03:24,880
 그래서 여기에 네트워크에서 진행하는 것은 우리가 가진 거의 동일한 코드입니다 

851
01:03:24,880 --> 01:03:29,150
 우리는 희망이 세 개의 작은 줄을 추가 한 제외하기 전에 경우를 볼 수 있습니다 

852
01:03:29,150 --> 01:03:34,280
 의 스칼라 요약을 계산하는 곳없는 당신은 그래서 여기에 저를 신뢰해야합니다 

853
01:03:34,280 --> 01:03:37,200
 손실 그것은 우리에게 새로운 상징적 인 변수를주고 

854
01:03:37,199 --> 01:03:40,929
 법의 개요 더욱 가중 행렬들의 히스토그램을 산출 요약 

855
01:03:40,929 --> 01:03:46,049
 화가 하나 W2 W 2 w도 우리에게 점점 새로운 상징적 인 변수에 W 

856
01:03:46,050 --> 01:03:51,390
 지금 우리가라는 또 다른 상징적 인 변수를 얻고 야유하는 것으로 나타났다 

857
01:03:51,389 --> 01:03:54,349
 함께 그렇게하지 ​​마법을 사용하는 모든 사람들 요약으로 부상 할 수 있습니다 

858
01:03:54,349 --> 01:03:58,929
 이해하고 우리는 우리가 사용할 수있는이 요약 작가 개체를 받고있어 

859
01:03:58,929 --> 01:04:03,000
 실제로 우리가있을 때 우리의 루프에서 지금 책상에 그 요약을 덤프하고 

860
01:04:03,000 --> 01:04:06,570
 실제로 다음 네트워크를 실행 우리는을 평가하는 평가를 말해 

861
01:04:06,570 --> 01:04:10,460
 교육 직원과 같은 손실 그녀의 모든 그래서이 병합 요약 개체 전에 

862
01:04:10,460 --> 01:04:14,190
 그래서 과시 요약을 평가하는 프로세스에서 계산할 것이다 개체 

863
01:04:14,190 --> 01:04:17,690
 이 가중치의 히스토그램을 계산합니다 그라데이션 책상에 그 요약을 덤프 

864
01:04:17,690 --> 01:04:22,019
 그리고, 우리는 요약에 내가 그 어디 같아요 실제로 우리의 작가에게 

865
01:04:22,019 --> 01:04:26,610
 그 다음에이 일을 실행하면 사용자가 쇼핑몰을 얻을 수 있도록이에 대한 권리가 발생합니다 

866
01:04:26,610 --> 01:04:28,890
 이 일을 지속적으로 정렬을 실행하는 모든이를 스트리밍 

867
01:04:28,889 --> 01:04:33,069
 책상에 네트워크에서 무슨 일이 일어나고 있는지에 대한 정보는 다음 당신은 

868
01:04:33,070 --> 01:04:37,480
 그 텐서 유량 센서 보드와 함께 제공되는이이 웹 서버를 시작하고 우리가 얻을 

869
01:04:37,480 --> 01:04:41,420
 그래서 당신의 네트워크에서 무슨 일이 일어나고 있는지에 대한이 아름다운 아름다운 시각화 

870
01:04:41,420 --> 01:04:42,539
 여기 왼쪽에 

871
01:04:42,539 --> 01:04:46,230
 회원 우리는 우리가이 때문에 손실 스칼라 요약을 얻고 있었다 말하고 있었다 

872
01:04:46,230 --> 01:04:49,360
 실제로 손실이 나는 그것이 큰 작은이었다 의미 내려가는 것을 보여줍니다 

873
01:04:49,360 --> 01:04:52,760
 네트워크 및 소규모 데이터 세트하지만 그 모든 의미가 작동이됩니다 

874
01:04:52,760 --> 01:04:56,860
 여기 오른쪽에 표시 당신은 당신을 보여주는 시간이 지남에 따라 히스토그램 

875
01:04:56,860 --> 01:05:00,900
 당신의 체중 행렬의 값의 분포이 물건은 그래서 

876
01:05:00,900 --> 01:05:04,579
 정말 정말 시원하고 나는이 정말 정말 아름다운 디버깅 도구라고 생각합니다 

877
01:05:04,579 --> 01:05:09,289
 내가 프로젝트와 토치 작업을했습니다 때 때 그래서 나는이 작성했습니다 

878
01:05:09,289 --> 01:05:11,250
 종류의 손으로 자신을 물건 

879
01:05:11,250 --> 01:05:14,900
 그냥 좀 고문에서 JSON의 모양을 덤핑하고 내 자신의 정의를 작성 

880
01:05:14,900 --> 01:05:18,369
 시각화 시각화은이기 때문에 통계의 이러한 종류를 볼 수 있습니다 

881
01:05:18,369 --> 01:05:21,609
 정말 유용하고 텐트 당신은 자신에 대해 어떤을 작성하지 않아도됩니다으로 

882
01:05:21,610 --> 01:05:25,019
 그들은 말을하는지 훈련 스크립트 실행에 코드를 사용하면 단지 몇 라인과 

883
01:05:25,019 --> 01:05:27,489
 당신은이 모든 아름다운 시각화하여 디버깅 도움을 얻을 수 있습니다 

884
01:05:27,489 --> 01:05:35,059
 tenser 유량 센서 보드는 또한 당신도 어떤 네트워크 시각화 할 수 있습니다 

885
01:05:35,059 --> 01:05:39,820
 이 이름을 가진 변수는 구조가 그래서 여기에 우리가 주석했던 모양이다 

886
01:05:39,820 --> 01:05:43,510
 지금 우리는 우리가 범위 실제로 몇몇을 할 수있는 전진 패스를하고있는 경우 

887
01:05:43,510 --> 01:05:47,450
 네임 스페이스와 함께 슬라이스 그룹의 종류에 따라 합병증 

888
01:05:47,449 --> 01:05:48,949
 계산이 

889
01:05:48,949 --> 01:05:52,519
 그것은과 동일합니다보다 함께 의미 지금 다른 속해야 

890
01:05:52,519 --> 01:05:56,949
 우리가 전에 지금보고 같은 것은 우리가이 네트워크를 실행하고 텐트를로드하는 경우 또는 

891
01:05:56,949 --> 01:06:00,909
 더 우리가 실제로 어떻게 같은이 아름다운 시각화를 얻을 수 있습니다 

892
01:06:00,909 --> 01:06:04,789
 우리의 네트워크는 실제로처럼 보이는 우리가 실제로 클릭하고 찾아 볼 수있는 

893
01:06:04,789 --> 01:06:07,820
 정말 무슨 점수에 화면 내부에 무슨 일이 일어나고 있는지 디버그에 도움 

894
01:06:07,820 --> 01:06:12,170
 이 네트워크 이집트 당신은 손실과 성적이 참조 

895
01:06:12,170 --> 01:06:15,030
 이는 우리가 포워드 패스 중에 정의 된 의미있는 네임 

896
01:06:15,030 --> 01:06:18,940
 우리가 예를 들어 점수를 클릭하면 그것을 열어 우리 모두 볼 수 있습니다 

897
01:06:18,940 --> 01:06:22,679
 그래픽에 계산 내부 여기에를 가지고 작업하는 

898
01:06:22,679 --> 01:06:28,108
 노드는 그래서 나는 정말 쉽게 디버그처럼 당신이 할 수 있다면 이것은 정말 멋진 줄 알았는데 

899
01:06:28,108 --> 01:06:31,039
 이 중 하나를 작성하는만큼 실행중인 동안 무슨 일이 당신의 네트워크 내부에서 무슨 일 

900
01:06:31,039 --> 01:06:39,300
 애플의 아시아 코드로 자신을 너무 부드러운 흐름은 멀티 GPU 지원을해야합니까 그래서 

901
01:06:39,300 --> 01:06:42,750
 데이터 병렬 그렇게 예상처럼 나는 것을 지적하고 싶습니다있다 

902
01:06:42,750 --> 01:06:45,809
 실제로는이 메일 부분은 아마도 중 하나입니다 배포 

903
01:06:45,809 --> 01:06:50,460
 실제로 시도 할 수있는 다른 주요 판매 포인트는 때때로 흐름 

904
01:06:50,460 --> 01:06:53,338
 다른 기기에서 다른 방법으로 분산 계산 쓰레기 

905
01:06:53,338 --> 01:06:57,828
 실제로 통신을 최소화하기 위해 기민하게 그 쓰레기를 분산 배치 

906
01:06:57,829 --> 01:07:02,839
 오버 헤드 등등 그래서 당신이 할 수있는 한 가지 데이터 병렬 어디에이다 

907
01:07:02,838 --> 01:07:05,559
 단지 다른 기기에서 다시 돈을 넣어 각 하나를 실행 

908
01:07:05,559 --> 01:07:08,409
 전후 다음 중 하나 그라디언트 중 일부는해야 할 일 

909
01:07:08,409 --> 01:07:12,068
 단지에 동기 업데이트를하거나 동기 분산 교육 당신의 

910
01:07:12,068 --> 01:07:16,730
 매개 변수와는 동기 훈련 뷰캐넌에게 그녀가 할 수있는 백서 주장을 

911
01:07:16,730 --> 01:07:21,300
 이런 것들과 텐서 흐름의 양을하지만 나는 그것을 밖으로 당신이 할 수하지 않았다 않았다 

912
01:07:21,300 --> 01:07:25,000
 또한 실제로뿐만 아니라 집중적 인 흐름 모델의 병렬 처리를 수행하지만 다음을 수행 할 수 있습니다 

913
01:07:25,000 --> 01:07:27,829
 같은 모델을 분할에 같은 모델의 다른 부분을 계산 

914
01:07:27,829 --> 01:07:32,190
 그래서 여기에 다른 장치는 그래서이 유용 할 수 있습니다 한 곳에는 예입니다 

915
01:07:32,190 --> 01:07:36,510
 다층 재발 네트워크가 실제로 실행하는 것이 좋습니다 수 있습니다 

916
01:07:36,510 --> 01:07:39,900
 다른 CPU에서 네트워크의 다른 레이어 그 일을 할 수 있기 때문에 

917
01:07:39,900 --> 01:07:42,838
 그 물건의 종류가 그래서 실제로 많은 메모리를 가지고 당신은 실제로 수 

918
01:07:42,838 --> 01:07:47,599
 당신은 너무 많은 고통없이 그 강한 공기 흐름을 할 수 않습니다 

919
01:07:47,599 --> 01:07:51,599
 tenser 흐름은 분산으로 실행할 수있는 프레임 워크의 유일한입니다 

920
01:07:51,599 --> 01:07:56,000
 하나의 시스템 및 다중 GPU를 실제로에서 모드뿐만 아니라 스트립 

921
01:07:56,000 --> 01:07:58,309
 그들에게 많은 기계에서 교육 모델을 배포 

922
01:07:58,309 --> 01:08:04,709
 광고 여기서주의해야 할 점은 그 부분은 아직 오늘로 평가 오픈 소스 아니라고 그래서 

923
01:08:04,708 --> 01:08:08,328
 텐서 흐름의 오픈 소스 버전은 단일 시스템 멀티 GPU 작업을 수행 할 수 있습니다 

924
01:08:08,329 --> 01:08:13,890
 훈련하지만 난 생각하지만 희망이 곧 그 부분은 정말로 발표 될 예정이다 

925
01:08:13,889 --> 01:08:16,500
 바로 그래서 여기에 멋진 

926
01:08:16,500 --> 01:08:22,069
 아이디어는 그냥 응답이 모두 통신 비용을 알고 있었다 끝낼 수있다 

927
01:08:22,069 --> 01:08:26,489
 네트워크에있는 다른 시스템 간의 또한 GPU와 CPU 만 사이에 그렇게 

928
01:08:26,488 --> 01:08:30,118
 그것은 현명 다른 걸쳐 계산 공예를 배포하려고 할 수 있습니다 

929
01:08:30,118 --> 01:08:33,750
 그 기계에서 다른 CPU에서 기계는 계산하기 

930
01:08:33,750 --> 01:08:37,649
 모든 가능한 한 효율적으로 그 그래서 난 그게 정말 멋진 생각 

931
01:08:37,649 --> 01:08:41,629
 즉 다른 프레임 워크가 바로 지금 일을 할 수없는 뭔가 

932
01:08:41,630 --> 01:08:46,409
 수십 흐름을 가리킬 수 있습니다 것은 초반 이었죠 모델 나는 보았다 그래서 나는 철저한했다 

933
01:08:46,408 --> 01:08:51,448
 구글은 검색과 내가 함께 올 수있는 유일한 방법은 처음 모듈가 있었다 

934
01:08:51,448 --> 01:08:56,028
 사전 시험 개시 모델 만이 탐구 안드로이드를 통해 만 접근 가능 

935
01:08:56,029 --> 01:08:59,569
 이 그들 있도록 모든 평가 내가 될 것으로 예상했을 것이다 뭔가 

936
01:08:59,569 --> 01:09:04,219
 명확한 문서가 더 있지만 그건 적어도 당신은 1 피치 모델이 

937
01:09:04,219 --> 01:09:09,109
 그 중 하나가 아닌 다른 내가 다른 초반 이었죠 모델의 정말 알고 아니에요 아니에요 

938
01:09:09,109 --> 01:09:12,109
 강한 공기 흐름하지만 어쩌면 어쩌면 어쩌면 그들은 거기있어, 내가 거기에 있습니다 

939
01:09:12,109 --> 01:09:13,230
 그냥 모르는 

940
01:09:13,229 --> 01:09:19,729
 확률값은 그래서 제대로 봤하지 말합니다 그 대답 흐름 장점과 단점 때문에 

941
01:09:19,729 --> 01:09:23,689
 다시는 내 빠른 일일 실험 정말 좋은 파이프 라인의 때문에 

942
01:09:23,689 --> 01:09:27,928
 나는 그것이 그래픽에 대한 계산이 아이디어를 가지고 알고 정말 멋진 심판 

943
01:09:27,929 --> 01:09:32,289
 이는 내가 슈퍼 강력 생각하고 실제로 이런 생각을합니다 

944
01:09:32,289 --> 01:09:35,948
 계산 그래프도 더 Fiano보다보다 정말와 같은 것들 

945
01:09:35,948 --> 01:09:40,000
 검사 점 및 장치를 통해 배포 이러한 모든처럼 알고 결국 

946
01:09:40,000 --> 01:09:46,380
 그것은 정말 멋진 그래픽 4000에 계산 내부의는 주장이다 

947
01:09:46,380 --> 01:09:49,520
 더 빨리가 나는 공포를 들었습니다 알고 시간 뭔가를 컴파일 

948
01:09:49,520 --> 01:09:53,670
 아마 컴파일 시간 반을 복용 신경 나무 기계에 대한 이야기 

949
01:09:53,670 --> 01:09:59,219
 어쩌면 그게 더 빠를 계획 또는 내가 들었어요 tenser 보드 외모 흐름한다 

950
01:09:59,219 --> 01:10:03,369
 놀라운 보이는 멋진 내가 사방에 그것을 사용하려면 

951
01:10:03,369 --> 01:10:07,340
 내가 훨씬 더 진보 된 생각 정말 멋진 데이터와 모델 모델 병렬 처리가 

952
01:10:07,340 --> 01:10:11,079
 다른 프레임 워크보다 배포 중지는 여전히 비밀 소스 있지만 

953
01:10:11,079 --> 01:10:15,689
 구글 만 잘하면 나는 결국 우리의 나머지 부분에 나올거야하지만 난 생각하는 것이 

954
01:10:15,689 --> 01:10:19,989
 밥이도 아마 실제로 기반 무서운 코드를 파고있어 말을 하였다으로 

955
01:10:19,989 --> 01:10:24,409
 후드 암에 대해 너무 적어도 나의 두려움에서 일하고 이해 

956
01:10:24,409 --> 01:10:29,010
 흐름은 당신 미친 이상한 필수적 코드와 어떤 종류의 작업을 수행하려는 경우 

957
01:10:29,010 --> 01:10:32,690
 쉽게 계산 그래프 추상화로 작동하지 않을 수 

958
01:10:32,689 --> 01:10:38,159
 당신은 문제를 많이 될 수있는 것 같다 같은 것은 우리에있어 고문에에의 할 수있다 

959
01:10:38,159 --> 01:10:40,659
 당신은 당신이 앞으로 내부에 원하는 필수적 어떤 코드를 작성할 수 있으며, 

960
01:10:40,659 --> 01:10:44,659
 이전 버전과 그들의 고유 한 사용자 정의의 패스하지만 가장 큰 유사한 것 

961
01:10:44,659 --> 01:10:49,979
 법의 톤 작업에 대한 나를 위해 점을 걱정하고 또 다른 연습 

962
01:10:49,979 --> 01:10:52,959
 어색한 일의 종류는 그 종류이다, 그래서 이완이 모델을 주셔서 감사하다 

963
01:10:52,960 --> 01:11:12,239
 의 총 

964
01:11:12,239 --> 01:11:22,019
 심지어 2002 년에 설치하는 것은 그들이이 주장 조금 아팠다 

965
01:11:22,020 --> 01:11:25,680
 파이썬은 우리 방금 다운로드 PEP에 설치할 수있는 모든하지만 파산 및 I 

966
01:11:25,680 --> 01:11:29,150
 그리고 그들은했다 설치 얻기 위해 매년 파일 이름을 변경했다 및 

967
01:11:29,149 --> 01:11:32,479
 내가 수동으로 업데이트했고, 같은 일부 랜덤를 다운로드 깨진 의존성 

968
01:11:32,479 --> 01:11:36,759
 zip 파일 그리고 그것은 결국 포장을 풀고 주위에 어떤 임의의 파일을 복사 할 수 있지만 

969
01:11:36,760 --> 01:11:41,520
 일을하지만 설치 내가 sudo는 2012이 심지어 내 자신의 컴퓨터에 어려웠다 

970
01:11:41,520 --> 01:11:47,400
 그래서 그들은 내가 함께이 빨리 넣어 그 함께 자신의 행동을 얻어야한다 

971
01:11:47,399 --> 01:11:51,529
 나는 사람들이 주에 대한 관심이라고 생각하면 종류의 커버 개요 표 

972
01:11:51,529 --> 01:11:55,529
 좀 초반 이었죠 모델이 무엇인지 언어 급류 프레임 워크 사이의 점 

973
01:11:55,529 --> 01:11:56,210
 유효한 

974
01:11:56,210 --> 01:12:05,029
 문제 

975
01:12:05,029 --> 01:12:09,988
 문제는 미안 이러한 지원 Windows의입니다하지만 난하지 않습니다 

976
01:12:09,988 --> 01:12:11,769
 알고있다 

977
01:12:11,770 --> 01:12:16,830
 난 당신이 자신에 있다고 생각 

978
01:12:16,829 --> 01:12:24,439
 앗 확인을 윈도우에서 AWS를 사용할 수 있습니다 

979
01:12:24,439 --> 01:12:29,359
 확인 그래서 나는이 빠른 간의 빠른 비교 차트 와서 함께 넣어 

980
01:12:29,359 --> 01:12:32,198
 나는 사람들이 관심있는 주요 총알 포인트의 일부를 커버 생각 프레임 워크 

981
01:12:32,198 --> 01:12:37,460
 이야기에 대해 어떤 언어가 자유 무역 모델을 가지고 있는지 여부를 손쉽게 

982
01:12:37,460 --> 01:12:41,300
 당신이 병렬 처리의 종류와 방법을 읽을 수있는 소스 코드 등의 여부 

983
01:12:41,300 --> 01:12:47,029
 내가하자 참조에 사용 사례 몇 가지를 가지고, 그래서 그들은 우리가 거​​룩한있어 우리의 손을 얻을 

984
01:12:47,029 --> 01:12:52,939
 쓰레기 우리는 250 슬라이드를 얻었고, 우리는 여전히 이분은의이의이하자하자하자 그렇게 떠났다 

985
01:12:52,939 --> 01:12:56,710
 약간의 게임은 당신이하고 싶었던 모든 알렉산드르의 BGG 추출한다고 가정 재생 

986
01:12:56,710 --> 01:12:58,619
 어떤 프레임 워크 기능은 당신이 선택할 것 

987
01:12:58,619 --> 01:13:06,969
 그래 내가 너무 일부에에 그물 알렉스를 찾을의 우리가하고 싶었던 모든 말을 하였다하자 

988
01:13:06,969 --> 01:13:19,189
 새로운 데이터는 그래의 우리가 미세 조정을 확인 I와 이미지 캡션을하고 싶은 말을하자 

989
01:13:19,189 --> 01:13:22,889
 좋은 분포를 들어 본 것은 그래서 이것은 내가이가 말하는 게 아니에요 내 생각 과정입니다 

990
01:13:22,890 --> 01:13:26,289
 나는 이것에 대해 생각하는 정답하지만 방법은 해당이 문제에 대한 우리 

991
01:13:26,289 --> 01:13:30,969
 초반 이었죠 모델은 카페 나 고문 라자냐 우리보고 있었다 초반 이었죠 모델 필요 

992
01:13:30,969 --> 01:13:36,239
 캐시는 거의 밖으로 사람들이 할 경우에도, 그래서 우리의 손이 필요합니다 

993
01:13:36,238 --> 01:13:39,869
 아마 고문을 사용하는 것 때문에 그냥 가지 고통이 물건을 구현 

994
01:13:39,869 --> 01:13:44,869
 어쩌면 우리는 모든 분류 할 의미 분할에 대해 라자냐 

995
01:13:44,869 --> 01:13:49,880
 우리는 입력 영상을 읽을 수와 대신을주는 바로 그래서 여기 화소를 

996
01:13:49,880 --> 01:13:57,900
 우리가 독립적으로 확인 모든 픽셀에 라벨을 할 전체 출력 이미지에 레이블을 

997
01:13:57,899 --> 01:14:01,969
 그 좋은 그렇게 다시 내 생각 과정은 우리가 여기 초반 이었죠 모델을 필요로했다입니다 

998
01:14:01,969 --> 01:14:06,800
 대부분 우리는 당신을 위해 이상한 사용 케이스의 종류에 대해 얘기 듣고 

999
01:14:06,800 --> 01:14:10,739
 이 레이어가 발생, 그래서 만약 우리 자신의 프로젝트의 일부를 정의 할 필요가 있습니다 

1000
01:14:10,738 --> 01:14:14,738
 그들은 레이더 자체의 다른 어떤 잘 맞는 것 카페에 존재 

1001
01:14:14,738 --> 01:14:23,109
 해결할없이 각 객체 검출을 위해 최소 10 점을 보이​​는이 일을 작성 

1002
01:14:23,109 --> 01:14:24,329
 생각 

1003
01:14:24,329 --> 01:14:30,750
 예 확인 캐시는 생각이 나의 생각 과정을 다시 우리가 초반 이었죠보고있는 것입니다 

1004
01:14:30,750 --> 01:14:33,149
 모델은 그래서 우리는 카페 필요 

1005
01:14:33,149 --> 01:14:38,069
 토치 또는 라자냐 우리는 실제로 문자 메시지로 당신이 많이 필요 할 수 있습니다 

1006
01:14:38,069 --> 01:14:41,609
 그것은 할 수 있습니다 펑키 필수적 코드는 계산에 넣어 

1007
01:14:41,609 --> 01:14:47,799
 11 선택이 카페 + 파이썬이 때문에 항공기하지만 나에게 무서운 것 같다의 일부가 

1008
01:14:47,800 --> 01:14:52,529
 우리가에 대한 이야기​​ 봄 실제로이 길을 갔고, 나는 실제로 일을했습니다 

1009
01:14:52,529 --> 01:14:56,939
 이 같은 유사 프로젝트와 나는 횃불을 선택하고 나를 위해 좋은 밖으로 일을하지만, 

1010
01:14:56,939 --> 01:14:59,809
 당신은 언어 모델링하려는 경우 펑키이 강렬 할 싶어하고 당신처럼 

1011
01:14:59,810 --> 01:15:06,270
 너희들의 일을 어떻게 재발 역할 토치와 함께 놀고 싶어 내가 네 

1012
01:15:06,270 --> 01:15:09,550
 우리가 원한다면 사실이 전혀 그래서 여기에 고문을 사용하지 않을 것 

1013
01:15:09,550 --> 01:15:13,650
 언어 모델링과는 우리가하지 않은 재발 관계의 펑키 종류의 일을 

1014
01:15:13,649 --> 01:15:17,109
 이 모든 단지 비과세의 이미지에 대해 이야기하는 것은 그래서 우리는 어떤 사전 시험이 필요하지 않습니다 

1015
01:15:17,109 --> 01:15:22,309
 모델과 우리가 정말 쉽게 재발 관계와 놀고 싶어 

1016
01:15:22,310 --> 01:15:25,430
 내가 생각하는 거기 때문에 현재 네트워크에서 작동하는 모든 반환에 아마 수수료 

1017
01:15:25,430 --> 01:15:32,570
 당신이 배치 표준을 구현하려는 경우입니다 흐름은 좋은 선택이 될 수 있습니다 

1018
01:15:32,569 --> 01:15:39,769
 당신이에 의존 할 경우 싶다면 확인 확인 그래서 여기에 그 권리 미안 슬라이드 

1019
01:15:39,770 --> 01:15:42,230
 당신은 그라데이션을 직접 운전하지 않는 당신은이에 의존 할 수 있다면 

1020
01:15:42,229 --> 01:15:46,899
 흐름처럼하지만 방식 때문에의 계산 공예 것들 그 것들 

1021
01:15:46,899 --> 01:15:50,089
 당신이 열정 숙제에서 본대로 작동하거나 실제로을 단순화 할 수 있습니다 

1022
01:15:50,090 --> 01:15:54,900
 꽤 많은 그라데이션 나는 확실하지 않다 이러한 계산 공예 프레임 워크 경우 

1023
01:15:54,899 --> 01:15:57,589
 이 효율적인 양식을 만드는까지 제대로 그라데이션을 단순화 것 

1024
01:15:57,590 --> 01:16:09,489
 문제 

1025
01:16:09,488 --> 01:16:13,009
 나는 질문이 구하기하는 방법 쉬운에 얼마나 쉽게입니다 생각 생각 

1026
01:16:13,010 --> 01:16:18,860
 피아노 모델 횃불 모델 같은과 나는 고통스러운 듯 보이지만에서 생각 

1027
01:16:18,859 --> 01:16:22,819
 fiato에서 적어도 당신은 라자냐 틱 틱 액세스 등 초반 이었죠 모델을 사용할 수 있습니다 

1028
01:16:22,819 --> 01:16:26,498
 빌어 먹을 함께 라자냐 모델은 뭔가 다른 내가 이론적으로 생각하다 

1029
01:16:26,498 --> 01:16:31,748
 당신이 원하는 경우에 당신이 진짜 진짜 좋아해 몇 가지가 있다면 아마 그래서 여기에 쉽게해야한다 

1030
01:16:31,748 --> 01:16:35,429
 정확히 어떻게 당신이 뒤로 패스를 할 방법에 대한 좋은 지식은 계산한다 

1031
01:16:35,429 --> 01:16:38,179
 당신은 당신이 아마 사용하지 않습니다보다 효율적으로 스스로를 구현하려는 

1032
01:16:38,179 --> 01:16:43,300
 토치 당신은 너무에 추천을 자신에게 물어 해당 백업을 구현할 수 있습니다 

1033
01:16:43,300 --> 01:16:46,949
 프레임 워크는 당신은 싶어 아마 기능의 특징 추출을 할 경우, 또는 

1034
01:16:46,948 --> 01:16:51,248
 기존 모델의 미세 조정하거나 간단 바닐라의 전송 

1035
01:16:51,248 --> 01:16:54,929
 작업은 다음 카페 아마 그렇지 사용하기 정말 쉽게 갈 수있는 올바른 방법이다 

1036
01:16:54,929 --> 01:16:58,649
 당신이 초반 이었죠 모델 주위에 작업 할 경우 임의의 코드를 작성해야하지만, 

1037
01:16:58,649 --> 01:17:02,738
 어쩌면 프놈펜 당신에게 잘을 초반 이었죠 모델 이상한 물건을하고 있지 

1038
01:17:02,738 --> 01:17:07,209
 라자냐 또는 토치의 더 나은 일을 할 수도 있습니다 것은 가지를에 쉽게있다 

1039
01:17:07,210 --> 01:17:11,328
 초반 이었죠 모델의 구조와 혼란 당신은 당신이 만약 정말로를 원하는 경우 

1040
01:17:11,328 --> 01:17:14,788
 정말 어떤 이유로 자신의 레이어를 작성하려는 당신은 당신을 생각하지 않는다 

1041
01:17:14,788 --> 01:17:18,788
 쉽게 이러한 계산 공예에 들어갈 수있는 것은 다음 아마도 경우 토치를 사용한다 

1042
01:17:18,788 --> 01:17:22,948
 당신은 정말 멋진 일 우리의 강렬하고 어쩌면 다른 유형을 사용하려면 그 

1043
01:17:22,948 --> 01:17:26,138
 계산 그래프에 따라 다음 아마에 어쩌면 요금을 이야기 

1044
01:17:26,139 --> 01:17:30,090
 당신이 거대한 모델이있는 경우 수익률도 낮은이고, 당신이 필요 

1045
01:17:30,090 --> 01:17:33,449
 전체 클러스터에서 배포하고 구글의 내부에 액세스 할 수 있습니다 

1046
01:17:33,448 --> 01:17:36,169
 코드베이스는 그녀 흐름을 사용해야합니다 

1047
01:17:36,170 --> 01:17:39,989
 내가 말했듯이 그 부분은 우리의 나머지 부분에 대한 발표 될 예정이다 희망이 있다고하지만, 

1048
01:17:39,988 --> 01:17:44,889
 당신 싶어 사용 텐트가 지루해하는 경우 곧 있도록도 그리고 당신이 너무 느린있어 

1049
01:17:44,890 --> 01:17:48,810
 즉, 그 모든의 꽤 많이 내 내 개요 내 빠른 회오리 바람 투어의의 

1050
01:17:48,810 --> 01:17:58,210
 에 대한 프레임 워크 어떤 그래서 어떤 마지막 순간 질문 질문 질문 

1051
01:17:58,210 --> 01:18:02,630
 그래서 약간의 속도를 비교하는 정말 좋은 페이지가 실제로 거기에 속도 

1052
01:18:02,630 --> 01:18:06,039
 벤치 마크 모든 다른 프레임 워크의 속도와 지금 한 그 

1053
01:18:06,039 --> 01:18:10,488
 승리 승리이 하나 하나도없는 것은이 일이 열반에서 저를 불려 

1054
01:18:10,488 --> 01:18:15,049
 이 사람이 실제로이 녀석을 쓴 있도록 시스템은 미친 그들 

1055
01:18:15,050 --> 01:18:20,119
 실제로 G4 및 비디오 하드웨어에 대한 자신의 정의 어셈블러를 쓴 사람들 

1056
01:18:20,119 --> 01:18:22,448
 같은과 동영상에 만족하지 않았다 

1057
01:18:22,448 --> 01:18:26,500
 툴체인 그들은 다음 유사한의 하드웨어와 회 전자를 리버스 엔지니어링 

1058
01:18:26,500 --> 01:18:30,948
 어셈블리에서 구현 된 모든 커널 자체가 그래서이 사람들이 

1059
01:18:30,948 --> 01:18:35,859
 미친 실제로이 존재하고, 그래서 자신의 물건은 정말 정말 빠릅니다 

1060
01:18:35,859 --> 01:18:39,309
 물건은 지금 실제로 가장 빠른하지만 난 정말 내가 그들의했습니다 사용한 적이 

1061
01:18:39,310 --> 01:18:42,510
 결코 정말 자신의 프레임 워크 나 자신을 사용하고 난 좀 덜 일반적인 생각 

1062
01:18:42,510 --> 01:18:47,010
 CUDA와 속도를 사용하는 사람에 대한하지만 이들은 대략이다 

1063
01:18:47,010 --> 01:18:52,030
 같은 지금 나는 약간의 다른 사람보다 10 여분 상당히 느린 생각 

1064
01:18:52,029 --> 01:18:55,609
 내가 생각하는 어리석은 이유는 후속 릴리스에서 만에 정리한다 

1065
01:18:55,609 --> 01:18:58,729
 적어도 근본적으로 당신이해야해야해야해야 할 이유가 없습니다 

1066
01:18:58,729 --> 01:19:04,209
 다른 사람보다 느린 

1067
01:19:04,210 --> 01:19:07,319
 당신의 사람들은 소총을 집어 들고있다 

1068
01:19:07,319 --> 01:19:24,279
 다 좋아 

1069
01:19:24,279 --> 01:19:27,198
 즉 실제로 미친 아니에요 대부분의 팀이 마지막에 대한 꽤있다 

1070
01:19:27,198 --> 01:19:29,738
 올해이 실제로 오프라 프로젝트와 같은 기호를 사용하고 그것을 잘했다 

1071
01:19:29,738 --> 01:19:34,658
 그래 나는 또한 다른 프레임 워크가 있다는 것을 언급해야한다 

1072
01:19:34,658 --> 01:19:45,359
 난 그냥이 가장 일반적인 질문에 대한 평화를 생각한다 

1073
01:19:45,359 --> 01:19:52,299
 그래서 질문은 잡아 토치 토치가 실제로있다, 그래서 내가 파이썬에 관한 것입니다 

1074
01:19:52,300 --> 01:19:56,770
 대령 실제로 종류의 멋진 나의 성화 노트북에서 사용할 수 있으며, 

1075
01:19:56,770 --> 01:20:00,150
 실제로 당신은 실제로 밤 또는 두 개의 노트북 만에 잡는 몇 가지 간단한 작업을 수행 할 수 있습니다 

1076
01:20:00,149 --> 01:20:04,899
 난 보통 내 데이터가 내 토치 모델은 데이터를 덤프 실행 덤프됩니다 않는 것을 실천 

1077
01:20:04,899 --> 01:20:09,899
 심지어 JSON의 HDL 5 파이썬에서 시각화에 조금 조금이다 

1078
01:20:09,899 --> 01:20:19,359
 고통스러운하지만 당신은 작업이 완료 얻을 수 있습니다 

1079
01:20:19,359 --> 01:20:23,309
 문제는 지루 tenser 당신이 넣을 수 있습니다 당신은 원시 데이터를 덤프 할 수 있는지 여부입니다 

1080
01:20:23,310 --> 01:20:28,300
 거기에 자신이 실제로 그들은 실제로 일부 로그에 모든 물건을 덤핑하고 

1081
01:20:28,300 --> 01:20:33,050
 임시 디렉토리에있는 파일 나는 사람들은 드문 드문 얼마나 쉽게 잘 모르겠어요하지만 당신은 할 수 

1082
01:20:33,050 --> 01:20:45,900
 쉽게 할 수있는 시도하거나 나는 문제가 있는지 있는지 질문하지 아니에요 

1083
01:20:45,899 --> 01:20:49,899
 이 현대적인 네트워크를위한 텐서 보드의 다른 타사 도구입니다 

1084
01:20:49,899 --> 01:20:53,269
 거기서 몇 가지있을 수 있습니다하지만 난 정말 그들을 사용한 적이 난 그냥 내 자신을 읽기 

1085
01:20:53,270 --> 01:20:58,159
 과거 다른 질문 

1086
01:20:58,158 --> 01:21:00,319
 확실히 나는 그게 생각 생각 

