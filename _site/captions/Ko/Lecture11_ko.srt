1
00:00:00,000 --> 00:00:03,428
 오늘날 우리가 통과하는 물건을 많이 가지고 오른쪽 그래서 나는 시작하고 싶습니다 

2
00:00:03,428 --> 00:00:08,669
 그래서 오늘 우리는 CNN의 실천에 대해 이야기 할 것과 많이 이야기하고 

3
00:00:08,669 --> 00:00:12,050
 정말 얻​​기 위해 언급되는 구현 세부 사항의 정말 낮은 수준의 종류 

4
00:00:12,050 --> 00:00:15,980
 당신이 실제로하지만 처음으로 일을 훈련 할 때 이런 일들이 작동합니다 

5
00:00:15,980 --> 00:00:20,189
 보통 우리는 번호 하나에 대해 이야기하는 일부 관리 물건을 그 통해이 

6
00:00:20,189 --> 00:00:24,600
 모든 TA에 의해 정말 영웅적인 노력은 모든 중간 고사가되도록 저하되어있다 

7
00:00:24,600 --> 00:00:27,740
 사람은 확실히 그 대해 감사해야하고 당신도 그들을 선택할 수 있습니다 

8
00:00:27,739 --> 00:00:34,920
 클래스 오늘 또는 여기있는이 근무 시간 중 어느 한 후에도 계속 

9
00:00:34,920 --> 00:00:38,609
 그 마음에 프로젝트 이정표는 자정 때문에 오늘 밤 수 있도록거야 

10
00:00:38,609 --> 00:00:41,628
 난 당신이 마지막에 대한 귀하의 프로젝트를 진행했습니다 희망 있는지 확인 

11
00:00:41,628 --> 00:00:45,579
 지난 주 정도에 대한 부부 등 몇 가지 정말 흥미로운 진전을 

12
00:00:45,579 --> 00:00:51,289
 그를 쓸 수 있는지 확인하고 더 더 드롭 박스에 할당 탭에서 그것을하지 넣지 

13
00:00:51,289 --> 00:00:55,460
 드롭 박스에 있지만 과정에서 할당 탭에 나는이 알고 죄송 것을 

14
00:00:55,460 --> 00:00:58,910
 정말 혼란하지만 단지 단지 등의 지정과 같은 탭을 할당 

15
00:00:58,909 --> 00:01:04,000
 할당이 잘하면 우리가 언젠가 수행해야합니다 그레이딩 작업을 하였다 

16
00:01:04,000 --> 00:01:10,140
 이번 주에 그 과제 세 가지가 너무 밖으로 기억하는 것은 어떻게이 진행되고있어 

17
00:01:10,140 --> 00:01:17,159
 나머지는 당신이 얻을해야하므로 좋은 사람이 누구 괜찮 수행 한 사람은 이루어집니다 

18
00:01:17,159 --> 00:01:22,740
 우리는 그래서 중간에서 약간의 재미 통계를 그래서 1 주일에 의한 때문에 시작 

19
00:01:22,739 --> 00:01:26,379
 당신이 당신의 성적을 볼 때 우리가 실제로이 정말 좋은했다 사촌 흥분하지 않습니다 

20
00:01:26,379 --> 00:01:30,759
 우리가하지 않는 아름다운 표준 편차 아름다운 가우스 분포 

21
00:01:30,759 --> 00:01:34,549
 그것이 내가 또한 지적하고 싶습니다 이미 완벽이 일을 정상화 비난해야 

22
00:01:34,549 --> 00:01:38,049
 그 사람이 일어나서에서 최대는 백 세 그들이있어 의미 점수 

23
00:01:38,049 --> 00:01:43,470
 즉, 그래서 바로 보너스의 모든는 아마에 하드 충분하지 의미 

24
00:01:43,469 --> 00:01:49,500
 우리는 또한 질문 당 일부는 평균 점수에 내 타악기 고장을 먹으 렴이 

25
00:01:49,500 --> 00:01:52,450
 당신이 뭔가를 가지고있는 경우 중간에 매 질문마다 그래서 만약 당신이 원하는 

26
00:01:52,450 --> 00:01:55,510
 잘못 당신은 다른 사람이 당신에게 잘못에 확인 갈 수 있어요 있는지 확인하려면 

27
00:01:55,510 --> 00:01:59,380
 당신이 당신의 자신의 시간에있어 이들 통계 리더 우리는 참 거짓에 대한 통계가 

28
00:01:59,379 --> 00:02:00,959
 와 객관식 

29
00:02:00,959 --> 00:02:04,729
 실제로 우리가 등급 중 결정 진정한 거짓이 해고 염두에 두어야 

30
00:02:04,730 --> 00:02:07,090
 그들은 그것을 버리고 당신에게 줄 약간 불공정라고 모든 

31
00:02:07,090 --> 00:02:12,960
 그 두 가지가 백퍼센트 왜 우리가이 통계에 대한이되는 점 

32
00:02:12,960 --> 00:02:19,810
 모든 개별 질문은 그래서 가서 그 이상으로 재미를 

33
00:02:19,810 --> 00:02:24,379
 내가 아는 마지막으로 그것은 동안이었다 그러나 우리는 중간을했고, 우리는 휴일이 있었다 

34
00:02:24,379 --> 00:02:28,030
 하지만 당신은 일주일 전에 우리가 재발에 대해 얘기했다 위에처럼 기억할 수있는 경우 

35
00:02:28,030 --> 00:02:31,509
 우리가 어떻게 재발 네트워크에 대해 이야기 네트워크 모델링에 사용할 수 있습니다 

36
00:02:31,509 --> 00:02:35,500
 이러한 피드 포워드 네트워크와 당신이 일반적으로 알고 서열 그들은 그것을 바쳐 그들이 

37
00:02:35,500 --> 00:02:39,139
 이 키보드 기능을 모델링하지만이 재발 네트워크를 우리는 방법에 대해 이야기 

38
00:02:39,139 --> 00:02:43,208
 그들은 우리가 이야기 순서 문제의 다른 종류를 모델링 할 수 

39
00:02:43,209 --> 00:02:48,319
 재발 네트워크 (10)의 특정 구현이 발표되고 앨리스와 

40
00:02:48,319 --> 00:02:51,539
 당신이 알아야 할 수 있도록 할당에 그 모두를 구현 무엇 

41
00:02:51,539 --> 00:02:56,079
 우리가이 올바른 재발 성 신경 네트워크가 될 수있는 방법에 대해 이야기하다 

42
00:02:56,080 --> 00:03:01,010
 언어 모델에 사용되는 일부 샘플 생성 된 텍스트를 보여주는 재미 있었다 

43
00:03:01,009 --> 00:03:06,329
 에 우리는 방법에 대해 이야기를의 셰익스피어와 대수 기하학이 무엇인지 

44
00:03:06,330 --> 00:03:09,590
 우리는 이미지를 할 수있는 길쌈 네트워크와 재발 네트워크를 결합 할 수 있습니다 

45
00:03:09,590 --> 00:03:14,180
 캡처 우리는 RNN의 신경 과학자 인의 조금이 게임을 

46
00:03:14,180 --> 00:03:17,700
 그리고 아르덴의 세포로 다이빙은 무엇을 해석하려고 

47
00:03:17,699 --> 00:03:21,879
 그들은 일을하는지 우리는 때때로 우리가이 끝없는 세포를 가지고 보았다 

48
00:03:21,879 --> 00:03:27,049
 꽤 멋진 문을 예를 들어 활성화를위한 선동하지만 

49
00:03:27,049 --> 00:03:28,890
 오늘 우리는 완전히 다른 무언가에 대해 이야기하는거야 

50
00:03:28,889 --> 00:03:33,339
 우리는 낮은 수준의 것들을 정말 많이 약거야 말거야 세 가지가 그 

51
00:03:33,340 --> 00:03:37,830
 세 가지 주요 테마가 그래서 당신은 실제로 CNN의 작업을 얻기 위해 알아야 할 

52
00:03:37,830 --> 00:03:41,600
 그것은 포푸리 약간의 그러나 우리는 그래서 그것을 함께 묶어하려고거야 

53
00:03:41,599 --> 00:03:45,349
 첫 번째는 정말 모든 주스를 압착된다 당신이 할 수없는 데이터의 정말 

54
00:03:45,349 --> 00:03:48,219
 당신이 큰 데이터 세트를 필요가 없습니다 특히 프로젝트에 대해 많이 알고 

55
00:03:48,219 --> 00:03:51,789
 우리는 데이터 증가 및 전송 학습에 대해 이야기 할 것중인 

56
00:03:51,789 --> 00:03:55,079
 당신이있어 특히이 정말 강력한 유용한 기술입니다 

57
00:03:55,080 --> 00:03:56,350
 작은 데이터 세트로 작업 

58
00:03:56,349 --> 00:04:00,889
 우리가 정말 회선에 깊은 다이빙에 대한 더 많은 이야기거야 

59
00:04:00,889 --> 00:04:05,959
 그 모두가 회선을 사용하여 효율적인 아키텍처를 설계 할 수있는 방법과 

60
00:04:05,960 --> 00:04:10,480
 기여 효율적으로 연습 한 후 최종적으로 구현되는 방법도 

61
00:04:10,479 --> 00:04:13,269
 우리는 뭔가에 대해 이야기거야하지만 일반적으로 구현에서 집중됩니다 

62
00:04:13,270 --> 00:04:17,480
 자세한 내용은 심지어 종이로하지 않고 사람과 같은 그 물건은이 

63
00:04:17,480 --> 00:04:21,750
 CPU와 경험 병목 어떤 종류의 GPU하고 당신에게 얼마나 많은 훈련 

64
00:04:21,750 --> 00:04:26,069
 물건을 많이의 여러 장치를 통해 여러 걸쳐 비가 배포 

65
00:04:26,069 --> 00:04:31,620
 우리의 내가 생각 데이터 증가에 대해 이야기 할 수 있도록 먼저 시작해야 

66
00:04:31,620 --> 00:04:34,910
 우리는 종류의이 강의 그러나 결코 지금까지 전달 될 수 있습니다 언급 한 

67
00:04:34,910 --> 00:04:39,780
 정말 당신이 CNN의 당신이 정말로있어 훈련 때 그래서 일반적으로 그것에 대해 이야기 

68
00:04:39,779 --> 00:04:44,179
 때 훈련 도중 파이프 라인의이 유형에 익숙해 거 부하 이미지를이야 

69
00:04:44,180 --> 00:04:48,379
 당신이거야 책상 오프 최대 레이블은 다음 CNN을 통해 이미지를 지불 

70
00:04:48,379 --> 00:04:51,009
 일부 손실을 계산하기 위해 라벨과 함께 이미지를 사용하는거야 

71
00:04:51,009 --> 00:04:55,610
 기능 및 역 전파를 업데이트 CNN과 이전의 반복 그 때문에 

72
00:04:55,610 --> 00:05:00,970
 문서상의가에 대해 이제 일에 의해 그와 정말 잘 알고 있어야합니다 

73
00:05:00,970 --> 00:05:05,960
 우리는 단지 우리가로드 한 후, 그래서 여기에이 파이프 라인에 하나의 작은 단계가 있었다 

74
00:05:05,959 --> 00:05:09,849
 책상 위의 이미지는 우리가 전달하기 전에 어떤 방법으로 그것을 변환하는거야 

75
00:05:09,850 --> 00:05:13,910
 그것을 CNN에이 변환은 라벨을 보존한다 

76
00:05:13,910 --> 00:05:19,090
 정말 간단하고 트릭 그냥 그래서 거 전파 돌아올와 CNN 

77
00:05:19,089 --> 00:05:24,089
 당신은 데이터 증가를 생각되어 사용되어야한다 변압기의 종류 

78
00:05:24,089 --> 00:05:27,679
 정말 간단 당신이 인위적으로 교육을 확장기 할 수 있습니다이 방법의 일종 

79
00:05:27,680 --> 00:05:32,030
 변환의 다른 종류의 현명한 사용을 통해 설정된 경우 그래서 당신 

80
00:05:32,029 --> 00:05:35,409
 이러한 시도로 컴퓨터가 정말로 이러한 이미지를보고있다 기억하고 몇 가지를 얻을 수 

81
00:05:35,410 --> 00:05:39,189
 픽셀 우리가 할 수있는 변환의 서로 다른 종류가있다 

82
00:05:39,189 --> 00:05:43,230
 그 레이블을 유지해야하지만 이는 모든 픽셀이 변경됩니다 당신이 경우 

83
00:05:43,230 --> 00:05:46,770
 그것을 왼쪽으로 그 고양이 1 픽셀을 출하처럼 상상하는 것은 여전히​​ 고양이하지만 모든입니다 

84
00:05:46,769 --> 00:05:50,539
 픽셀을 사용하면 문서에 대해 이야기 할 때 그래서 그 변경 예정 

85
00:05:50,540 --> 00:05:54,680
 당신은 종류의 당신이 당신의 훈련을 확대하고 상상하고 

86
00:05:54,680 --> 00:05:58,629
 교육 및 새로운 기본 훈련 샘플은 상관 관계하지만 여전히 것 

87
00:05:58,629 --> 00:06:03,389
 당신은 방지와 더 큰 모델과 모델을 훈련하는 데 도움이 매우이다 

88
00:06:03,389 --> 00:06:04,959
 매우 광범위하게 연습에 사용 

89
00:06:04,959 --> 00:06:08,668
 거의 모든 CNN 당신은 그 대회에서 우승거나 잘하고있어 참조 

90
00:06:08,668 --> 00:06:09,810
 벤치 마크는 일부를 사용하고 있습니다 

91
00:06:09,810 --> 00:06:15,889
 비트 증가에서 가장 쉬운 그래서 역은 수평 뒤집기 경우입니다 

92
00:06:15,889 --> 00:06:18,699
 당신이 거울 이미지가해야 미러 이미지를 볼 때 우리는이 고양이를 생각한다 

93
00:06:18,699 --> 00:06:22,949
 여전히 고양이 일이 방금 할 수있는 심판을 구현하기 위해 정말 정말 간단합니다 

94
00:06:22,949 --> 00:06:27,159
 단일 통화 마찬가지로 쉽고 다른 토치 단 한 줄의 코드와 함께 할 

95
00:06:27,160 --> 00:06:32,040
 프레임 워크이 정말 쉽다는 아주의 다른 널리 사용되는 뭔가를 변화 

96
00:06:32,040 --> 00:06:37,120
 널리 교육 시간 있도록 훈련 이미지에서 임의의 작물을하는 데 사용 

97
00:06:37,120 --> 00:06:40,949
 (A)에서 이미지에 대한 패치를 가지고 우리는 그녀의 이미지를로드거야 그리고 우리는거야 

98
00:06:40,949 --> 00:06:42,629
 임의의 규모와 위치 

99
00:06:42,629 --> 00:06:47,189
 우리는 CNN의는 어떤 크기를 기대하고 고정으로 크기를 조정 한 다음과 같은 것을 사용하여 우리의 

100
00:06:47,189 --> 00:06:51,389
 예를 훈련하고 다시이 아주 아주 널리 그냥 사용하는 것은 당신에게 맛을 제공 

101
00:06:51,389 --> 00:06:56,610
 이 사용 방법을 정확하게의 전 주민에 대한 세부 사항을 그들이 그렇게 고개 

102
00:06:56,610 --> 00:07:01,639
 실제로 각 교육 이미지 크기 조정 종이 스티커 난수 교육 시간을 가졌다 

103
00:07:01,639 --> 00:07:05,620
 짧은면 해당 번호는 다음 샘플이되도록 전체 이미지 크기를 조정 

104
00:07:05,620 --> 00:07:09,720
 다음 임의의 크기 조정 차원에서 224 작물로 224 그리고 같은 것을 사용 

105
00:07:09,720 --> 00:07:13,990
 훈련 샘플은 그래서 도움이 일반적으로 구현하는 데 아주 쉽게 그리고 

106
00:07:13,990 --> 00:07:20,560
 꽤 당신은 데이터 증가 일반적으로 사물의 형태를 사용하고 그렇게 할 때 

107
00:07:20,560 --> 00:07:25,269
 약간의 테스트 시간이 양식을 사용하므로 교육 시간 변경 

108
00:07:25,269 --> 00:07:29,079
 데이터 증가는 네트워크가 정말 긴장 전체 이미지에 훈련되지 않습니다 

109
00:07:29,079 --> 00:07:34,219
 그의 작물에 정말 이해하거나 강제로 시도 공정하지 않는 것 때문에 

110
00:07:34,220 --> 00:07:38,900
 네트워크는 내가 연습 할 때 그렇게 보통 해요 테스트로 전체 이미지를 볼 수 있습니다 

111
00:07:38,899 --> 00:07:42,879
 당신은 미국에서 데이터 증가에 대한 임의 자르기 이런 종류의 일을하고 

112
00:07:42,879 --> 00:07:48,379
 시간 당신은 작물의 일부 고정 세트가 그래서 매우 테스트하기 위해 다음을 사용합니다 

113
00:07:48,379 --> 00:07:52,019
 일반적으로 당신은 당신이 왼쪽 손을 잡고 것이다 열 작물을 볼 것을 볼 수 있습니다 

114
00:07:52,019 --> 00:07:52,649
 모서리 

115
00:07:52,649 --> 00:07:56,189
 당신 하단 모서리와 중심을 제공하는 오른쪽 상단 모서리 

116
00:07:56,189 --> 00:08:00,800
 함께 수평 플립에서 오는 10 그가 그 (10) 작물 할게요 제공하는 

117
00:08:00,800 --> 00:08:06,460
 그래서 그 (10) 작물의 네트워크를 통해 평균 점수를 통과 시험 시간 

118
00:08:06,459 --> 00:08:09,519
 공진 실제로 더 그 조금 한 단계 소요 실제로 수행 

119
00:08:09,519 --> 00:08:14,759
 다중 스케일 다중 스케일이가 경향이 뭔가뿐만 아니라 시간을 증명 

120
00:08:14,759 --> 00:08:20,649
 실제로 성능이 도움 구현 다시 아주 쉽게 널리 사용되는 다양 

121
00:08:20,649 --> 00:08:26,418
 우리가 일반적으로 48 증가 할 또 다른 점은 그렇다면 컬러 생성입니다 

122
00:08:26,418 --> 00:08:29,529
 당신은 아마 어쩌면 고양이의이 사진을 찍을는 그 조금 cloudier했다 

123
00:08:29,529 --> 00:08:33,348
 그 날 우스운 우리가 많이보다 사진을 촬영했을 경우 하루 조금 

124
00:08:33,349 --> 00:08:37,070
 색상의 너무 한 가지 아주의 그 상당히 달라졌을 것이다 

125
00:08:37,070 --> 00:08:40,360
 방금 전에 색상 우리 교육의 이미지를 조금 변경하면된다하는 것이 일반적 

126
00:08:40,360 --> 00:08:45,539
 내가 아주 간단한 방법은 그냥이가있는 반면 변화입니다 해요 그래서 우리는 CNN에 도착 

127
00:08:45,539 --> 00:08:50,469
 매우 수행하는 매우 간단한을 쉽게 구현할 수 있지만, 실제로는 실제로 당신은 볼 수 있습니다 

128
00:08:50,470 --> 00:08:55,759
 이 흔하지 조금 동안 계약 대신 당신이 볼은 그 

129
00:08:55,759 --> 00:09:01,259
 이상의 주성분 분석을 사용하여이 약간 더 복잡한 파이프 라인 

130
00:09:01,259 --> 00:09:06,439
 학습 데이터의 모든 화소 아이디어이라는 각 화소에 대한 우리 

131
00:09:06,440 --> 00:09:11,390
 훈련 데이터는 길이 3의 RGB이 벡터이며 우리는 그 화소를 수집하는 경우 

132
00:09:11,389 --> 00:09:15,129
 전체 훈련 데이터를 통해 당신은 색상의 종류의 감각을 얻을 것을 

133
00:09:15,129 --> 00:09:19,330
 일반적으로 다음 주성분 분석을 사용하여 트레이닝 데이터에 존재 

134
00:09:19,330 --> 00:09:23,930
 우리에게 색 공간이 종류의 세 가지 주요 구성 요소의 방향을 제공합니다 

135
00:09:23,929 --> 00:09:27,879
 색상이 데이터 세트에서 변화하는 경향이 따라 방향이 무엇인지를 알려 

136
00:09:27,879 --> 00:09:32,429
 색상 확대 술에 대한 교육 시간에 시험보다 너무 

137
00:09:32,429 --> 00:09:35,889
 우리는 실제로 훈련의 색깔이 주요 구성 요소를 사용할 수 있습니다 

138
00:09:35,889 --> 00:09:41,419
 성별 훈련시에 색이 다시 얼마나 사이트 정확하게 선택할 

139
00:09:41,419 --> 00:09:46,719
 조금 더 복잡하지만 꽤 널리 PCA 이러한 유형의 있도록 사용 

140
00:09:46,720 --> 00:09:51,580
 내가 생각하는 색상의 구동 데이터의 증가는 알렉스 도입 한 것 

141
00:09:51,580 --> 00:09:58,310
 2012 년 종이 및 또한 예를 들어 ResNet에 사용되는 데이터의 증가 때문에 

142
00:09:58,309 --> 00:10:02,829
 이 매우 일반적인 일이 바로 당신이 단지에 대해 생각하고 싶지 이스라엘 당신의 

143
00:10:02,830 --> 00:10:06,420
 변환의 종류는 당신이 당신의 클래스 불에 원하는 작업 데이터 세트 

144
00:10:06,419 --> 00:10:11,179
 다양한 너무 그리고 당신은에 변화의 그 유형을 소개하고 싶습니다 

145
00:10:11,179 --> 00:10:15,229
 훈련 데이터 교육 시간 그리고 당신이 정말로 여기에 미쳐 얻을 수 있습니다 

146
00:10:15,230 --> 00:10:18,740
 정말 창의적이고는 데이터에 대해 생각하고 어떤 종류의 편차를 

147
00:10:18,740 --> 00:10:23,659
 당신은 아마 랜덤처럼 그것을 시도 할 수 있습니다 귀하의 데이터에 대한 의미가 있습니다 

148
00:10:23,659 --> 00:10:27,708
 몇도 회전 할 수있다 데이터에 따라 회전은 의미가 

149
00:10:27,708 --> 00:10:31,399
 당신은 스트레칭과 시뮬레이션하기 위해 전단의 다른 종류처럼 시도 할 수 있습니다 

150
00:10:31,399 --> 00:10:33,189
 데이터의 아마 아핀 변환 

151
00:10:33,190 --> 00:10:36,990
 그리고 당신이 정말로 여기에 미쳐과 창의력을하려고 생각할 수 

152
00:10:36,990 --> 00:10:43,840
 내가 지적하고 싶은에 대한 데이터와 다른 일을 할 수있는 흥미로운 방법 

153
00:10:43,840 --> 00:10:49,009
 데이터 증가의이 아이디어는 정말 지금 우리가했습니다 큰 테마에 맞는 것입니다 

154
00:10:49,009 --> 00:10:54,090
 볼이 과정을 통해 여러 번 반복이 팀은 하나의 방법이다 

155
00:10:54,090 --> 00:10:58,420
 즉 정기적으로 overfitting 방지하기위한 연습에 정말 유용 

156
00:10:58,419 --> 00:11:02,209
 라이더는 훈련 도중 네 번째 패스 동안 우리가 훈련 할 때이다 

157
00:11:02,210 --> 00:11:05,930
 네트워크 우리와 종류 혼란에 이상한 확률 잡음의 일종했다 

158
00:11:05,929 --> 00:11:10,629
 네트워크는 데이터 증가와 예를 들어 우리가 실제로 수정하고 

159
00:11:10,629 --> 00:11:14,210
 우리가 떨어 뜨리거나 같은 것을 사용하여 네트워크에 넣어 학습 데이터 

160
00:11:14,210 --> 00:11:18,860
 네트워크의 임의의 부분을 복용하고 그는 그들이 설정하는 연결 drop하여 

161
00:11:18,860 --> 00:11:22,730
 프로세서의 활성화 임의로 가중치 20 아르 

162
00:11:22,730 --> 00:11:28,450
 이것은 또한 이것은 또한 패치 보쉬 정상화와 종류의 표시가 

163
00:11:28,450 --> 00:11:31,930
 정규화하여 정규화 내용의 다른 것들에 의존 

164
00:11:31,929 --> 00:11:35,000
 그래서 정상적인 훈련 중에 배치 

165
00:11:35,000 --> 00:11:39,440
 같은 이미지는 서로 다른 다른 이미지와 많은 일괄 적으로 나타나는 끝낼 수 있습니다 

166
00:11:39,440 --> 00:11:43,840
 실제로 나는 시간을 훈련 잡음 만의 모든 유형을 소개합니다 

167
00:11:43,840 --> 00:11:47,690
 이러한 예는 테스트 시간 우리는 데이터 증가에 대한 그래서이 소음을 평균 

168
00:11:47,690 --> 00:11:52,790
 우리 모두가 드롭 아웃에 대한 훈련 데이터의 다양한 샘플에 걸쳐 평균을 

169
00:11:52,789 --> 00:11:56,870
 그리고 일종의 평가할 수를 연결 삭제하고이를 소외 

170
00:11:56,870 --> 00:12:01,090
 우리가 자신을 계속 실행 계속 더 분석적으로 작은 및 전망 정상화 

171
00:12:01,090 --> 00:12:05,269
 그래서 난 그냥 그 이러한 아이디어를 많이 통합 할 수있는 좋은 방법의 종류 생각 의미 

172
00:12:05,269 --> 00:12:08,960
 정규화는 다음 전진 패스에 노이즈를 추가 할 수 있습니다 때이다 

173
00:12:08,960 --> 00:12:13,540
 당신이 올하려는 경우 한 번에 이상 소외 너무 마음에 계속 

174
00:12:13,539 --> 00:12:20,250
 그 주요 테이크 아웃을 그래서 다른 창조적 인 방법은 네트워크를 정례화하기 

175
00:12:20,250 --> 00:12:24,149
 데이터 증가에 대한 하나 그것을 구현하는 것이 정말 간단하다는 있습니다 

176
00:12:24,149 --> 00:12:28,329
 그래서 당신은 거의 항상 변명하지에 그것을 정말이 아니에요 사용해야합니다 

177
00:12:28,330 --> 00:12:32,730
 그것은 내가 당신을 많이 생각하는 작은 데이터 세트를 위해 특별히 아주 아주 유용합니다 

178
00:12:32,730 --> 00:12:36,850
 프로젝트에 사용하고 또한이 프레임 워크와 멋지게에 맞는 

179
00:12:36,850 --> 00:12:41,509
 교육 및 소외에서 잡음이 난 테스트 그래서 나는 그 꽤의 생각 

180
00:12:41,509 --> 00:12:45,360
 많은 모든 질문이 그래서 데이터 증가에 대해 말할 수있다 

181
00:12:45,360 --> 00:12:45,840
 그것에 대해 

182
00:12:45,840 --> 00:13:01,840
 네 시간 훈련에 많은 시간이 걸릴 것 내가 지금 얘기 행복 해요 

183
00:13:01,840 --> 00:13:05,790
 디스크 공간이 많이 난 그렇게 가끔 해요 있도록 책상이 일을 덤프 시도 

184
00:13:05,789 --> 00:13:08,879
 사람들은 창의력과 배경이 그들의 일치하는 데이터를 스레드처럼도 있습니다 

185
00:13:08,879 --> 00:13:16,799
 및 문서 바로 그래서 나는 그것이 우리가 이야기 할 수는 분명 생각 

186
00:13:16,799 --> 00:13:21,069
 다음 생각은 그래서 당신이 작업 할 때 그 주위에 떠있는이 신화있다 

187
00:13:21,070 --> 00:13:25,770
 CNN의 당신은 정말 많은 양의 데이터가 필요하지만 그 이전 것이 밝혀 

188
00:13:25,769 --> 00:13:33,029
 이 정말 간단 레시피가 당신이 할 수있다, 그래서이 신화를 학습하는 파열된다 

189
00:13:33,029 --> 00:13:37,769
 전송 학습에 사용할 그게 먼저 당신은 무엇이든 좋아하는을 

190
00:13:37,769 --> 00:13:42,879
 CNN 아키텍처는 알렉스 문제 BG 또는 무엇을 당신과 당신이 훈련 중 하나가 있습니다 

191
00:13:42,879 --> 00:13:46,970
 이미지가 아래로 더 일반적으로에 대한 자신 또는 당신은 자유 무역 병을 다운로드하지 

192
00:13:46,970 --> 00:13:51,360
 불과 20 분 거리에 쉽게 인터넷이 수행하는 많은 시간을 다운로드 

193
00:13:51,360 --> 00:13:56,590
 훈련 할 수 있지만, 일반적으로 두 종류의 거기 옆에 당신은 아마 그 부분을하지 않습니다 

194
00:13:56,590 --> 00:14:00,910
 경우 하나의 데이터 세트가 정말 작고, 당신이 정말로 어떤이없는 경우 

195
00:14:00,909 --> 00:14:05,019
 이미지는 무엇이든지 당신은 단지 고정 된 기능으로이 분류를 처리 할 수 

196
00:14:05,019 --> 00:14:10,110
 추출기 그래서이 보는 한 가지 방법은 당신이 마지막 층 할게요이다 

197
00:14:10,110 --> 00:14:15,580
 소프트 맥스 병원 아시아 모델 멀리 걸릴 것 네트워크 그는거야 

198
00:14:15,580 --> 00:14:18,370
 작업에 대한 선형 분류의 일종으로 대체 당신을 

199
00:14:18,370 --> 00:14:21,810
 실제로 걱정 이제 네트워크의 나머지 부분을 동결거야, 그리고 

200
00:14:21,809 --> 00:14:26,969
 해당 상위 레이어를 재교육하는 것은 그래서 이것은 일종의 그냥 훈련에의 것과 동일 

201
00:14:26,970 --> 00:14:31,230
 네트워크에서 추출 된 기능의 상단에 직접 선형 분류 그래서 

202
00:14:31,230 --> 00:14:35,149
 당신이이 경우에 대한 연습에 시간을 많이 볼 것은 그런 종류입니다 

203
00:14:35,149 --> 00:14:38,399
 전처리 단계로 당신은 모든 테스트하는 기능을 덤프합니다 당신의 

204
00:14:38,399 --> 00:14:42,100
 이미지를 훈련하고 있기 때문에 그 캐스트 기능의 상단에 완전히 작동 

205
00:14:42,100 --> 00:14:48,110
 꽤 속도 일을 도와 그것은 매우 매우를 사용하여 아주 쉽게 할 수 있습니다 

206
00:14:48,110 --> 00:14:51,250
 일반적인 보통 많은 문제를위한 매우 강력한 기준을 제공한다 

207
00:14:51,250 --> 00:14:56,169
 당신은 실제로 발생하고 수도 당신보다 조금 더 많은 데이터가있는 경우 

208
00:14:56,169 --> 00:14:58,599
 당신은 실제로 더 편안 훈련을 감당할 수 

209
00:14:58,600 --> 00:15:03,949
 모델은 그래서 일반적으로 일부 부품을 고정합니다 데이터 집합의 크기에 따라 

210
00:15:03,948 --> 00:15:07,669
 다음 하부 네트워크 층과 일부 대신 오직 재교육의 

211
00:15:07,669 --> 00:15:11,919
 마지막 은신처 당신은 방법에 따라 훈련 마지막 편지의 일부 번호를 선택합니다 

212
00:15:11,919 --> 00:15:16,349
 당신이 더 큰 데이터 세트를 사용할 수있을 때 더 큰 데이터 세트는 일반적이며, 

213
00:15:16,350 --> 00:15:21,350
 당신이 훈련을 다음 최종 그들의 더 ​​많은 훈련을 감당할 다시이라면 할 수 있습니다 

214
00:15:21,350 --> 00:15:26,060
 당신은 매우 일반적입니다 볼 수 있습니다 무엇을 여기에 트릭에 비슷한 유사 

215
00:15:26,059 --> 00:15:29,729
 그 대신 실제로 명시 적으로이 부분을 계산 당신은 덤프합니다 

216
00:15:29,730 --> 00:15:35,019
 이 마지막 층은 책상에 기능하고 메모리에이 부분에서 작동되도록 

217
00:15:35,019 --> 00:15:47,490
 꽤 많은 일들을 빠르게 때로는 나는 기본적 것을 질문 할 수 있습니다 

218
00:15:47,490 --> 00:15:51,959
 그것을 시도하고 볼 수 있지만 특히 작은 데이터 세트 이러한 유형의 작동해야 

219
00:15:51,958 --> 00:15:55,799
 당신이 원한다면 그냥 할 것처럼 당신이있는 경우에 경우에 이미지가 꽤을 검색하도록 

220
00:15:55,799 --> 00:16:01,338
 그렇게이 될 수 있도록 강력한베이스 라인은 CNN의 기능에 LTE 거리를 사용한다 

221
00:16:01,339 --> 00:16:05,110
 당신이 훈련해야 할 것으로 예상 얼마나 많은 샘플 방식의 유형은 내가 하모니를 의미 

222
00:16:05,110 --> 00:16:10,470
 당신이 당신이 가진 것보다 더 많은이 경우 연방 수사 국 (FBI)이나 뭐 같은 이들에 대한 많은 

223
00:16:10,470 --> 00:16:15,310
 당신보다 더 많은 데이터는 그래서 좋은시는 그 시도에 필요한 기대 

224
00:16:15,309 --> 00:16:28,879
 전혀 어쩌면 내가 그래 당신은 가끔 미안 당신이 실제로 것입니다 의존하고있어 

225
00:16:28,879 --> 00:16:32,309
 전진 패스를 통해 실행하지만 때로는 당신은 단지 네 개의 패스를 실행 

226
00:16:32,309 --> 00:16:36,818
 한 번이 꽤 일반적입니다 좀 그건의 두 책상을 덤프 

227
00:16:36,818 --> 00:16:41,458
 실제로 계산을 절약 

228
00:16:41,458 --> 00:16:59,729
 랜덤 하우스에서 당신은 아마 당신이 다른 수업을해야합니다 

229
00:16:59,730 --> 00:17:03,350
 러시아어 문제이나 뭐하지만이 이러한 다른 중간층 

230
00:17:03,350 --> 00:17:08,750
 당신은 실제로와의 이전 모델에 있던 어떤에서 초기화 

231
00:17:08,750 --> 00:17:15,068
 당신이 실제로 할 수있는 좋은 팁을 찾아 연습 나쁜있다가 

232
00:17:15,068 --> 00:17:18,588
 당신은 괜찮아요 때 레이어의 세 가지 유형을 추측하는 경우에만 층 두 가지 유형의 수 

233
00:17:18,588 --> 00:17:22,349
 그들은 당신이있는 것으로 생각할 수있는 냉동 층 수 있습니다 튜닝은 

234
00:17:22,349 --> 00:17:27,448
 제로의 속도를 학습이 새로운 래리가 유리 초기화한다는 것이다있다 

235
00:17:27,449 --> 00:17:32,548
 처음부터 일반적으로 사람들은 너무 어쩌면 더 높은 학습 속도 만이 

236
00:17:32,548 --> 00:17:36,528
 네트워크는 원래 서쪽 훈련이 있었는지의 높은 어쩌면 십분 및 

237
00:17:36,528 --> 00:17:40,079
 우리는 당신이에서 초기화하는이 중간층을해야합니다 

238
00:17:40,079 --> 00:17:43,269
 전 열차 네트워크는하지만 당신은 동시 최적화를 수정할 계획하고 

239
00:17:43,269 --> 00:17:47,470
 당신이 경향이 있습니다 이러한 중간층 있도록 미세 조정은 매우 작게 

240
00:17:47,470 --> 00:17:56,589
 원래의 학습 속도 어쩌면 한 백 그래 

241
00:17:56,589 --> 00:18:04,319
 그 어떤 사람들은 일반적으로 그것을 조사하기 위해 노력하고 발견이다 

242
00:18:04,319 --> 00:18:08,079
 미세 조정 미세 조정 방식의 작품을 학습 전송이 유형의 

243
00:18:08,079 --> 00:18:11,710
 더 나은 네트워크는 원래 데이터의 비슷한 유형의 훈련을받은 때 

244
00:18:11,710 --> 00:18:16,610
 어떤 것을 의미하지만, 사실이이 매우 낮은 수준의 기능을 가지 있습니다 

245
00:18:16,609 --> 00:18:20,308
 아마 적용 할 수 원하지되어 가장자리와 색상과 가버 필터 등 

246
00:18:20,308 --> 00:18:24,190
 단지에 대한 시각 모든 유형의 데이터 그래서 특히 이러한 낮은 수준의 기능 I에 

247
00:18:24,190 --> 00:18:29,009
 생각하는 거의 모든과 방법에 의해 일반적으로 꽤 적용 할 수있는 나는 또 다른 

248
00:18:29,009 --> 00:18:33,788
 당신은 당신이 때로는 미세 조정을위한 연습에서 볼 수 있다고 팁은 당신 것입니다 

249
00:18:33,788 --> 00:18:37,609
 첫째는 동결 여기서 실제로 다단 방식을 가질 수도 

250
00:18:37,609 --> 00:18:42,079
 다음 전체 네트워크에만이 지난 후에 다음이 마지막 은신처 및 훈련 

251
00:18:42,079 --> 00:18:46,939
 층 돌아가서 실제로 인디 당신이 할 수있는 것을 발견 한 후 수렴 것으로 보인다 

252
00:18:46,940 --> 00:18:51,519
 때로는이 때문에이 마지막 층 초기화이 문제가 

253
00:18:51,519 --> 00:18:54,690
 무작위로 당신은 엉망이 어떤 종류의 매우 큰 경사가있을 수 있습니다 

254
00:18:54,690 --> 00:18:59,070
 초기화는 두 가지 방법 중 하나를이 동결되는 주위를 얻을 수 있도록 

255
00:18:59,069 --> 00:19:02,788
 처음에는이 수렴을 쓰는 사람이나이 베어링 학습 속도를 가짐으로써 

256
00:19:02,788 --> 00:19:08,658
 그래서 네트워크 전송 학습이 아이디어의 두 정권 사이 

257
00:19:08,659 --> 00:19:14,470
 실제로 정말 잘 몇 꽤 초기 논문은 2013 거기 때문에 작동 

258
00:19:14,470 --> 00:19:19,390
 2014 CNN의 당은 특히이 하나의 인기가 점점 시작했을 때 

259
00:19:19,390 --> 00:19:24,490
 그들은했다 용지가 있었다 놀라운베이스 라인 그들이 무슨 짓을했는지 매우 담담했다 무엇 

260
00:19:24,490 --> 00:19:26,009
 당시 최고 중 하나였다 

261
00:19:26,009 --> 00:19:30,470
 해외에서 CNN의 아웃 위업에 걸쳐 있었다 그들은 단지 추출 기능과 

262
00:19:30,470 --> 00:19:33,640
 다른 표준 데이터 세트 및 표준의 무리에 이러한 기능을 적용 

263
00:19:33,640 --> 00:19:38,679
 컴퓨터 비전의 문제하고는 이러한 권리 아이디어에 비해 

264
00:19:38,679 --> 00:19:42,210
 그들은 시간이 매우 전문을에서 무엇과 비교된다 

265
00:19:42,210 --> 00:19:45,298
 각 개인에 대한 파이프 라인 및 매우 전문적인 아키텍처 

266
00:19:45,298 --> 00:19:49,408
 문제와 데이터 세트 및 각 문제에 대해 그들은 단지이 매우 교체 

267
00:19:49,409 --> 00:19:54,380
 기능의 상단에 아주 간단한 선형 모델의와 전문 파이프 라인 

268
00:19:54,380 --> 00:19:58,559
 피트와 서로 다른 데이터 세트의 모두를 위해 이런 짓을 발견 

269
00:19:58,558 --> 00:20:01,940
 일반적으로 전체 이러한 이상 - 더 - 상단 교사는 아주 아주이었다 있음 

270
00:20:01,940 --> 00:20:06,080
 강한베이스 라인과 몇 가지 문제들은 기존보다 실제로 더 좋았다 

271
00:20:06,079 --> 00:20:08,428
 방법과 몇 가지 문제에 대해 그들이 있었다 

272
00:20:08,429 --> 00:20:12,879
 이 이것은 정말 멋진 종이했을 정도로 악화하지만 여전히 매우 경쟁력 얻을 그 

273
00:20:12,878 --> 00:20:16,118
 다만 이들에 사용될 수있다 정말 강한 특징이 있다고 입증 

274
00:20:16,118 --> 00:20:19,949
 다른 작업의 많은 아주 잘 작동하는 경향이 사람들을 따라 다른 종이 

275
00:20:19,950 --> 00:20:25,419
 라인은 카페인 용지 및 디카 페인 나중에되었다되었다 버클리 출신 

276
00:20:25,419 --> 00:20:33,610
 카페인과 그가가가 너무 혈통의 종류의이다, 그래서 카페가되었다 

277
00:20:33,609 --> 00:20:37,388
 전송 학습을위한 조리법의 종류는 당신에 대해 생각해야 있다는 것입니다 

278
00:20:37,388 --> 00:20:43,398
 이 행렬을 구입하기에 너무 작은 무엇 초반 이었죠로 설정 데이터 방법과 유사하다 

279
00:20:43,398 --> 00:20:47,989
 모델이었고, 데이터의 양을 당신이 할 당신은 그 4에 어떻게해야 

280
00:20:47,990 --> 00:20:53,240
 당신은 매우 유사한 데이터 세트와 매우있는 경우에 그래서 일반적으로 다른 열 

281
00:20:53,240 --> 00:20:57,538
 단지 네트워크를 사용하여 약간의 데이터는 특징 추출기 및 훈련을 수정 한 

282
00:20:57,538 --> 00:21:02,429
 이러한 기능의 상단에 간단한 선형 모델은 경우에 아주 잘 작동하는 경향이있다 

283
00:21:02,429 --> 00:21:06,470
 당신이 미세 조정을 시도하고 실제로 시도하려고 할 수있는 것보다 조금 더 많은 데이터를 가지고 

284
00:21:06,470 --> 00:21:10,509
 사전 심사 무게와 실행에서 미세 조정에서 네트워크를 초기화 

285
00:21:10,509 --> 00:21:15,868
 다른 열이에서 최적화이 상자 여기에 약간의 트릭이다 

286
00:21:15,868 --> 00:21:20,099
 당신은 당신이 창의력을 시도하고 아마 대신 할 수 있습니다 문제가 될 수 있습니다 

287
00:21:20,099 --> 00:21:23,998
 맨 마지막 층으로부터 특징을 추출하면이 기능을 추출 시도 할 수 있습니다 

288
00:21:23,999 --> 00:21:27,470
 다른 대륙의 레이어와 그 때로는 때로는 도움이 될 수 있습니다에서 

289
00:21:27,470 --> 00:21:32,819
 직관이있다 어쩌면 아마도 이러한 MRI 데이터 등 뭔가 

290
00:21:32,819 --> 00:21:37,178
 매우 최고 수준의 기능은 매우 구체적인 이미지 지금 범주는하지만, 이러한 

291
00:21:37,179 --> 00:21:42,059
 매우 낮은 수준의 기능을 할 수처럼 가장자리와 물건 같은 것들입니다 

292
00:21:42,058 --> 00:21:47,980
 켜 분명 이미지 네트 기술 데이터 세트를 켜 더 양도 

293
00:21:47,980 --> 00:21:51,099
 이 상자에 당신은 더 나은 모양에있어 다시 당신은 일종의 초기화 할 수 있습니다 

294
00:21:51,099 --> 00:21:57,928
 미세 곧 내가 지적하고 싶은 다른 일이 초기화이 좋습니다 

295
00:21:57,929 --> 00:22:01,590
 초반 이었죠 모델과 미세 조정으로 실제로는 예외 아니다 

296
00:22:01,589 --> 00:22:05,439
 당신이 볼 수있는 거의 모든 큰 시스템에서 거의 표준 연습 

297
00:22:05,440 --> 00:22:09,070
 컴퓨터 비전 요즘 우리는 실제로이 두 가지 예를 본 적이 

298
00:22:09,069 --> 00:22:13,220
 이미 분기 예를 들어, 당신은 몇 강의 전에서 기억한다면, 그래서 

299
00:22:13,220 --> 00:22:17,220
 우리는 이미지를보고 우리가 CNN했다 물체 검출에 대해 이야기 

300
00:22:17,220 --> 00:22:21,620
 지역의 제안이 다른 호출이이 모든 미친 것들하지만이 부분 

301
00:22:21,619 --> 00:22:25,529
 CNN과 우리가 CNN이보고 한 이미지 및 이미지 캡션보고 있었다 

302
00:22:25,529 --> 00:22:29,399
 이미지는 이러한 경우 모두에서, 그래서 CNN의 처음 imagefap에서입니다 되었더라도 

303
00:22:29,400 --> 00:22:34,080
 모델과 그 정말이 다른보다 전문적인 문제를 해결하는 데 도움이 

304
00:22:34,079 --> 00:22:38,839
 심지어 거대한 데이터 세트없이 또한 이미지 캡션 모델에 대한 

305
00:22:38,839 --> 00:22:42,829
 이 모델의 특정 부분이 당신이해야 할 것을 요구 하였다 포함 

306
00:22:42,829 --> 00:22:47,500
 당신이 그것을 시작하지만 사람들은 벡터 아니었다면 숙제를 지금까지 본 

307
00:22:47,500 --> 00:22:50,099
 당신은 실제로 아마이었다 뭔가에서 초기화 할 수 있습니다 

308
00:22:50,099 --> 00:22:54,019
 과세의 무리를 사전에 훈련하고 때로는 일부 검색에 아마 도움이 될 수 있습니다 

309
00:22:54,019 --> 00:22:58,668
 어떤 상황에서 사용 가능한 캡처 데이터를 많이 가지고하지 않을 수 있습니다 경우 

310
00:22:58,669 --> 00:23:15,490
 그래 나는 문제가에 따라 달라집니다에 의존 때로는 도움이 왔어요 

311
00:23:15,490 --> 00:23:18,859
 네트워크는하지만 확실히 당신이 시도 할 수 있습니다 뭔가하고 특히 수도 

312
00:23:18,859 --> 00:23:27,548
 이 상자에있을 때 도움이되지만 그래 그것은 테이크 아웃에 좋은 트릭 

313
00:23:27,548 --> 00:23:31,210
 대한 미세 조정은 정말 정말 좋은 생각을 사용해야한다는 것입니다 

314
00:23:31,210 --> 00:23:35,950
 그것은 실제로 정말 잘 작동하도록 그래 당신이해야 아마 거의 

315
00:23:35,950 --> 00:23:39,900
 항상 그것을 사용하고 어느 정도는 일반적으로 교육되고 싶지 않아 

316
00:23:39,900 --> 00:23:42,519
 처음부터이 일이 정말 정말 큰 데이터 집합이없는 경우 

317
00:23:42,519 --> 00:23:45,970
 거의 모든 상황에서 사용할 수있는 것이 훨씬 더 편리 

318
00:23:45,970 --> 00:23:52,279
 카페 기존 모델과 방식에 의해 발견하면이 기존 모델이 

319
00:23:52,279 --> 00:23:58,230
 당신은 많은 사람들이 많은 유명한 이미지로 모델을 존재 다운로드 할 수 있습니다 

320
00:23:58,230 --> 00:24:01,880
 실제로 잔류 네트워크 공식 모델은 아주 최근에 출시있어 

321
00:24:01,880 --> 00:24:06,130
 당신도 다운로드 정말 멋진 이들 카페 것 그것으로 재생할 수 있습니다 

322
00:24:06,130 --> 00:24:09,020
 새로운 모델 모델은 일종의 표준의 약간처럼 

323
00:24:09,019 --> 00:24:13,759
 지역 사회 당신은 심지어 같은 다른 다른 프레임 워크에 카페 모델을로드 할 수 있도록 

324
00:24:13,759 --> 00:24:17,658
 토치는 그래서 그 다음 카페 모델이 상당히 있다는 사실을 양지해야 할 무언가이다 

325
00:24:17,659 --> 00:24:21,030
 유용 못했습니다 

326
00:24:21,029 --> 00:24:26,889
 미세 조정 또는 전송 학습에 어떤 추가 질문 

327
00:24:26,890 --> 00:24:46,650
 당신이 높게을 시도 할 수 있도록 그래 그건 아주 크고 낮은 차원의 

328
00:24:46,650 --> 00:24:50,250
 그 꼭대기에 선형 모델을 정례화하거나 작은 올 퍼팅 시도 할 수 있습니다 

329
00:24:50,250 --> 00:24:53,109
 어쩌면 차원을 줄일 그 꼭대기에에서 여기 창조적 얻을 수 있습니다 

330
00:24:53,109 --> 00:24:56,399
 하지만 난 당신이 그 일을 할 수 시도 할 수있는 일이있다가 있다고 생각 

331
00:24:56,400 --> 00:25:03,640
 데이터가에 따라 적합한 그래서 우리가 더 이야기해야한다고 생각 

332
00:25:03,640 --> 00:25:07,740
 회선이 모든 네트워크에 대해 우리는 그것에 대해 정말 이야기했습니다 있도록 

333
00:25:07,740 --> 00:25:11,920
 회선은 많은 작업을하고있어 계산 주력이다 

334
00:25:11,920 --> 00:25:18,090
 네트워크는 그래​​서 우리는 회선 처음에 대해 약 두 가지를 얘기해야 

335
00:25:18,089 --> 00:25:22,809
 우리는 효율적인 네트워크 아키텍처를 설계 할 수있는 방법 그래서 그들을 막을 방법입니다 

336
00:25:22,809 --> 00:25:28,789
 여기에, 그래서 몇 가지 멋진 결과를 달성하기 위해 회선의 많은 레이어를 결합 

337
00:25:28,789 --> 00:25:33,230
 질문은 우리가 사람들의 두 개의 층이있는 네트워크를 가지고 있다고 가정 내가 

338
00:25:33,230 --> 00:25:37,190
 이 같은 세 개의 기여가 입력 될이 활성화 될지도 

339
00:25:37,190 --> 00:25:40,120
 제 1 층이 두 층의 후 활성화 NAP 것 

340
00:25:40,119 --> 00:25:45,959
 회선 문제는이 두 번째 층 상에이란에 대한 지역의 얼마나 큰 

341
00:25:45,960 --> 00:25:49,640
 입력이 표시되지 않습니다에이 내가 희망 나는 귀하의 중간에 있던 나는 U 너희들 희망 

342
00:25:49,640 --> 00:25:53,920
 모두가 이에 대한 답변을 알고 

343
00:25:53,920 --> 00:26:01,298
 확인 사람은 아마 그 힘든 시험 문제였다 

344
00:26:01,298 --> 00:26:05,230
 하지만이 다섯으로 다섯입니다 그리고 그것은이에서 볼 꽤 쉽게이다 

345
00:26:05,230 --> 00:26:08,989
 그림은 왜 두 번째 층까지이 신경이보고 될 수 있도록 

346
00:26:08,989 --> 00:26:13,619
 일부 특정이 픽셀의 중간에서 전체 볼륨 

347
00:26:13,618 --> 00:26:18,138
 중간 우리가 그렇게 할 때를 입력 세 지역에 따라이 세 가지에서 찾고 

348
00:26:18,138 --> 00:26:22,738
 이보다 다음의 세 가지를 모두 볼 때 모두에서 평균 

349
00:26:22,739 --> 00:26:26,200
 두 번째 또는 세 번째 층에있는이 신경을 은신처는 사실이보고있다 

350
00:26:26,200 --> 00:26:32,669
 우리가 있던 경우에 입력 다섯 부피 다섯 전체 괜찮 이제 질문은 

351
00:26:32,669 --> 00:26:36,820
 에서 지역의 얼마나 큰 행에 쌓여 세 개의 회선으로 삼피트 

352
00:26:36,819 --> 00:26:43,700
 입력 이유로 같은 종류의 그가 수용 필드가 있다고 그래서 그들은 나중에 무엇을보고 

353
00:26:43,700 --> 00:26:49,739
 여기에 포인트를 만들 수 있도록 단지 종류의 연속 공헌 구축 

354
00:26:49,739 --> 00:26:53,940
 당신이 실제로 매우 줄 33 세에 의해 회선을 알고있다 

355
00:26:53,940 --> 00:26:57,919
 비슷한 표현 능력은 하나의 일곱 일곱하여 내 주장이다 

356
00:26:57,919 --> 00:27:02,619
 컨볼 루션은이의 정확한 의미에 대한 토론을 할 수 있도록 당신은 할 수 

357
00:27:02,618 --> 00:27:05,528
 하지만 단지에서 같은 그것에 대해 정리하고 물건을 증명하려고 

358
00:27:05,528 --> 00:27:09,940
 직관적 인 감각 그들은 333 회선 비슷한 유형을 나타낼 수 있습니다 

359
00:27:09,940 --> 00:27:14,100
 그것은에서 찾고 있기 때문에 일곱 기여하여 유사한 칠 등의 기능 

360
00:27:14,099 --> 00:27:22,189
 입력에 동일한 입력 영역 그래서 지금 생각은 지금 실제로 우리는 더 팔 수있다 

361
00:27:22,190 --> 00:27:27,399
 이 아이디어로 우리는 하나 797 사이에보다 구체적으로 비교할 수 있습니다 

362
00:27:27,398 --> 00:27:32,618
 그래서이 가정하자 세 공헌 33의 스택 대 컨볼 루션 

363
00:27:32,618 --> 00:27:38,638
 우리는 바다로 HIW의 입력 이미지를 가지고 우리는 회선을하도록 

364
00:27:38,638 --> 00:27:43,329
 우리가 필터를 볼 그래서 그 깊이를 보존하고 우리는 그들을 갖고 싶어 

365
00:27:43,329 --> 00:27:48,019
 그래서 우리가 적절하고 우리가 원하는 두드리며 말했다으로 높게 보존 식품 

366
00:27:48,019 --> 00:27:51,528
 구체적으로 비교 한 일곱의 차이에 의한 것입니다하기 

367
00:27:51,528 --> 00:27:56,648
 이러한 각각의 세 가지 그래서 처음 몇 주에 의해 세의 스택 대 칠 

368
00:27:56,648 --> 00:28:01,748
 두 가지 사람이 얼마나 많은 무게 단일 일곱 일곱으로의 가스가있다 

369
00:28:01,749 --> 00:28:09,519
 컨볼 루션 집과는 편견에 대해 잊을 수는 혼동 

370
00:28:09,519 --> 00:28:19,869
 나는 약간의 여름을 들었지만 나의 내 대답 나는 바로 그것을 가지고 희망을 들어 

371
00:28:19,869 --> 00:28:24,319
 49 C는 각자가 찾고있는 일곱 일곱하여 회선을 가지고로 제곱했다 

372
00:28:24,319 --> 00:28:29,809
 볼의 깊이에서 당신은 지금 49 C 제곱 있도록 이러한 필터를 보게되었다하지만 

373
00:28:29,809 --> 00:28:34,649
 세 개의 회선 세에 의해 우리는 회선의 세 층 각 하나가 

374
00:28:34,650 --> 00:28:38,990
 각 필터는 스티브으로 세 가지로 세 가지이며, 각 플레이어는 때 필터를 볼 수 있습니다 

375
00:28:38,990 --> 00:28:43,980
 모든 아웃 우리가 무료로 회선 33 만 제곱 (27) C가 볼 것을 곱 

376
00:28:43,980 --> 00:28:49,079
 매개 변수와 우리는 이러한 각각의 사이에 후 레이 루이스가 있다고 가정 

377
00:28:49,079 --> 00:28:54,049
 기여는 우리는 세 개의 회선으로 최대 33 스택이 실제로 있는지 참조 

378
00:28:54,049 --> 00:28:58,649
 이런 종류의 좋은 좋은 더 비선형이다 적은 수의 매개 변수 

379
00:28:58,650 --> 00:29:02,960
 의 여러 세에 의해 당신에게 세 가지의 이유 스택에 대한 몇 가지 직관을 제공합니다 

380
00:29:02,960 --> 00:29:06,440
 세 개의 회선은 실제로 하나의 일곱 칠로하는 것이 바람직 할 수있다 

381
00:29:06,440 --> 00:29:11,559
 경쟁은 우리가 실제로 더이 한 단계 걸릴에 대해 생각 할 수 있습니다 

382
00:29:11,559 --> 00:29:14,750
 하지 일반 매개 변수 아래 단지 수 있지만, 실제로 꿀 부동 

383
00:29:14,750 --> 00:29:19,099
 이 일에 소수점 연산 그래서 사람이 얼마나 많은 가스가 걸릴 

384
00:29:19,099 --> 00:29:29,669
 이러한 일들이 지금 수행 할 작업이이 실제로 하드 쓰기 소리 

385
00:29:29,670 --> 00:29:33,740
 때문에 이러한 필터 각각에 대해 매우 쉽다는 거의 모든 IT를 사용했다 

386
00:29:33,740 --> 00:29:37,819
 이미지의 단부에 위치하므로 실제 곱셈의 광고의 수는 

387
00:29:37,819 --> 00:29:42,099
 단지거야 시간이 Heights의 배 가연성 필터의 수를 당신 때문에 

388
00:29:42,099 --> 00:29:47,789
 실제로 여기에 그것을 볼 수 있습니다 다시뿐만 아니라 우리 사이에 있나요 

389
00:29:47,789 --> 00:29:52,440
 이 두 가지 사이에 일곱으로 칠 작업을 비교하는 것은뿐만 아니라 더 많은 학습 가능이 

390
00:29:52,440 --> 00:29:57,460
 매개 변수하지만 실제로 잘 스택 있도록 더 많은 컴퓨터에 비용 

391
00:29:57,460 --> 00:30:03,140
 자주 암시로 (33)는 다시 적은 컴퓨팅 우리에게 더 비선형 성을 제공하므로 

392
00:30:03,140 --> 00:30:06,170
 그 좀 당신에게 왜 실제로 여러 층을 갖는 몇 가지 직관을 제공합니다 

393
00:30:06,170 --> 00:30:12,300
 세 베이 세 회선하지만 다음 큰 필터 실제로 바람직하다 

394
00:30:12,299 --> 00:30:15,750
 우리가 작은쪽으로 밀어 봤는데 알고 또 다른 질문을 생각할 수 있으며, 

395
00:30:15,750 --> 00:30:20,109
 작은 필터하지만 왜 바로 우리가 실제로 작은 갈 수있는 세 가지에 의해 세에서 정지 

396
00:30:20,109 --> 00:30:21,859
 그건있을 수 있습니다보다 같은 논리 확장 것 

397
00:30:21,859 --> 00:30:27,798
 머리를 흔들어 당신은 당신이 얻을하지 않습니다 그것은 사실 그 사실을 믿지 않는다 

398
00:30:27,798 --> 00:30:33,539
 우리가 여기서 할거야 그래서 실제로 무엇을 수용 필드는 단일 비교된다 

399
00:30:33,539 --> 00:30:39,019
 약간 애호가 아키텍처 병목 아키텍처 대 33 회선 

400
00:30:39,019 --> 00:30:45,150
 그래서 여기에 우리는 내가 HW의 입력이보고 우리가 실제로 할 수있는들을 수있는 거 가정하고 

401
00:30:45,150 --> 00:30:50,070
 이것은 우리가까지 볼 수있는 단일 하나씩 회선을 멋진 트릭 

402
00:30:50,069 --> 00:30:54,609
 필터는 실제로 지금이 볼륨의 차원을 줄이기 위해 

403
00:30:54,609 --> 00:30:57,990
 것은 동일한 공간 범위이지만 기능 절반이 예정 

404
00:30:57,990 --> 00:31:03,480
 심층 지금 우리는거야이 병목을 수행 한 후 3 × 3 할 

405
00:31:03,480 --> 00:31:08,929
 이 감소 차원에서 컨볼 루션 지금이이 세 가지에 의해 

406
00:31:08,929 --> 00:31:13,610
 세 개의 회선 입력 기능을 통해 받아 출력에 이상 발생 

407
00:31:13,609 --> 00:31:18,000
 기능과 이제 우리는 하나 다른 하나를 사용하여 차원을 복원 

408
00:31:18,000 --> 00:31:23,558
 이 펑키 한 가지 종류의 볼 백업을 통해 볼에서 회선은 이동 

409
00:31:23,558 --> 00:31:27,910
 아키텍처는 하나씩 회선을 사용하는이 아이디어는 어디 에나있다 

410
00:31:27,910 --> 00:31:31,669
 그것은이 직관을 가지고 있기 때문에 때로는 네트워크와 네트워크라는 것을 

411
00:31:31,669 --> 00:31:35,730
 당신은 하나씩 회선이 완전히 연결 슬라이딩에 좀 유사하다있어 

412
00:31:35,730 --> 00:31:42,480
 당신의 입력 볼륨의 각 부분에 걸쳐 네트워크와이 아이디어도 나타납니다 

413
00:31:42,480 --> 00:31:46,259
 구글 매트와이 하나씩 병목 현상을 사용 ResNet이 생각 

414
00:31:46,259 --> 00:31:52,679
 기여 그래서 우리는 하나이이 병목 샌드위치를​​ 비교할 수 있습니다 

415
00:31:52,679 --> 00:31:56,390
 C 필터와 세 개의 회선에 의해 세와 같은 논리를 통해 실행 

416
00:31:56,390 --> 00:32:01,270
 그래서 나는 당신의 머리에있는 컴퓨터에 강제하지 않습니다하지만 당신은 할 수 있습니다 

417
00:32:01,269 --> 00:32:02,720
 이 날 믿어하기 

418
00:32:02,720 --> 00:32:08,700
 이 병목 스택은 세 가지를 가지고 어디 분기 C는 매개 변수를 제곱 것을 

419
00:32:08,700 --> 00:32:12,360
 여기이 사람은 우리가 고집하는 경우 구 C가 다시 매개 변수를 제곱있다 

420
00:32:12,359 --> 00:32:15,879
 이 병목 이상이 기여 각각의 사이에 집회 

421
00:32:15,880 --> 00:32:20,620
 샌드위치는 적은 수의 우리에게 더 많은 비선형 성을주고있다 

422
00:32:20,619 --> 00:32:28,899
 우리는 실제로 같은 우리 유사한 매개 변수 및 대 세에 의해 세에서 본 

423
00:32:28,900 --> 00:32:33,200
 일곱으로 칠 매개 변수의 수는 그렇게 계산에 직접 연결되어 

424
00:32:33,200 --> 00:32:35,389
 이 병목 샌드위치도 

425
00:32:35,388 --> 00:32:39,788
 훨씬 빠른 하나씩 병목 현상이 아이디어에 따라서이를 계산한다 

426
00:32:39,788 --> 00:32:52,669
 구글 매트에서 최근에 사용 꽤 많이 받고 특히 그래 그렇게 

427
00:32:52,669 --> 00:32:56,579
 당신은 때때로 당신이에서 투사로로 생각 당신은 그것의 생각 

428
00:32:56,578 --> 00:33:00,308
 다시 더 높은 차원 공간에 다음의 경우 낮은 차원 기능 등 

429
00:33:00,308 --> 00:33:03,868
 당신은 어떻게 서로의 상단에 이런 일을 많이 쌓아 생각 

430
00:33:03,868 --> 00:33:09,499
 당신이 한 직후오고 것보다보다 주민 

431
00:33:09,499 --> 00:33:11,088
 하나 또 하나가 될 것 

432
00:33:11,088 --> 00:33:14,858
 당신은 가지 위에 많은 많은 한 사람들 하나 하나 회선 붙어있어 

433
00:33:14,858 --> 00:33:18,918
 서로 하나씩 회선 조금 슬라이딩 같이하는 완전히 

434
00:33:18,919 --> 00:33:23,409
 각각의 이중 채널을 통해 다층 완전히 연결 네트워크는 아마 생각 생각하는 

435
00:33:23,409 --> 00:33:27,229
 그것에 대해 때 조금하지만 실제로 당신이 정말 안 밝혀 

436
00:33:27,229 --> 00:33:31,200
 공간적 범위를 필요로하고, 심지어 단 하나의 세 가지로 샌드위치를​​ 비교 

437
00:33:31,200 --> 00:33:35,769
 세 Khans하여 정렬의 동일한 입력 출력 볼륨 크기를 갖는하고 있지만, 

438
00:33:35,769 --> 00:33:41,429
 더 비선형 그들이있어 그래서 저렴 계산과 동물 매개 변수는 무엇입니까 

439
00:33:41,429 --> 00:33:46,089
 이 것입니다 모든 좋은 기능의 종류 만이 거기에 하나의 문제입니다 

440
00:33:46,088 --> 00:33:49,668
 즉, 우리는 여전히 어딘가에서 3 × 3 회선을 사용하고 그리고 

441
00:33:49,669 --> 00:33:54,709
 우리는 우리가 정말이 필요하면 경우에 당신이 궁금해 할 수 대답은 그것이 나오는 것에 없음입니다 

442
00:33:54,709 --> 00:33:59,808
 내가 최근에 본 적이 한 미친 것은 당신이 당신이 인수 분해 할 수 있다는 것입니다 

443
00:33:59,808 --> 00:34:05,608
 하나 2003 년에 세 개의 회선으로 거리와 세에 의해 원에 비해 

444
00:34:05,608 --> 00:34:09,469
 단일 세에 의해 세 개의 회선이 몇 가지 매개 변수를 저장 끝 

445
00:34:09,469 --> 00:34:14,428
 뿐만 아니라 당신이 정말로 당신으로이 일에 의해 올 수 미쳐 경우 수도 있기 때문에 

446
00:34:14,429 --> 00:34:18,019
 세와 함께이 병목와 하나 세 생각과 사물 단지 

447
00:34:18,018 --> 00:34:22,358
 정말 저렴받을 수 있도록 구글이 가장에서 무슨 짓을했는지 기본적이다 

448
00:34:22,358 --> 00:34:27,038
 인 셉션의 최신 버전은 그렇게 미친 종이의이 종류가를 다시 생각있다 

449
00:34:27,039 --> 00:34:30,389
 그들이이 많이 재생 컴퓨터 비전에 대한 개시 아키텍처 

450
00:34:30,389 --> 00:34:34,169
 이상한 방법으로 회선을 감안하고있는에 관하여 미친 트릭 

451
00:34:34,168 --> 00:34:37,138
 다른에 하나씩 병목 현상을 많이하고 예측 백업 

452
00:34:37,139 --> 00:34:40,608
 당신이 생각 치수 다음 경우 원래 구글과 만나 자신의 

453
00:34:40,608 --> 00:34:42,699
 처음 모듈은 미친이었다 

454
00:34:42,699 --> 00:34:46,118
 이 일이 구글이 지금에 사용하고있는 개시 모듈입니다 것 

455
00:34:46,119 --> 00:34:47,329
 그들의 최신 개시 

456
00:34:47,329 --> 00:34:50,739
 여기에 흥미로운 기능은 다음 하나씩을 가지고 있습니다 

457
00:34:50,739 --> 00:34:55,819
 모든 곳에서 병목 현상이에 대한 이러한 비대칭 필터를 가지고 있는지 확인 

458
00:34:55,820 --> 00:35:01,519
 에이 계산 그래서이 물건은 슈퍼 널리 아직 사용되지 않지만, 그것은 그것의의의 

459
00:35:01,519 --> 00:35:05,079
 거기 그것은 구글 매트는 그것을 언급 멋진 무언가를 정신병이야 

460
00:35:05,079 --> 00:35:14,610
 이렇게 빨리 회선에서 개괄하고는 보통의 것입니다 스택하는 방법 

461
00:35:14,610 --> 00:35:18,530
 대신 큰 필터 크기의 하나의 큰 회선을 갖는의 더 나은 

462
00:35:18,530 --> 00:35:22,740
 그것은 여러 개의 작은 필터로하고 있음을 해체하는 것이 더 나은에도 

463
00:35:22,739 --> 00:35:26,339
 어쩌면이 BGG 같은 사이의 차이를 설명하는 데 도움이 

464
00:35:26,340 --> 00:35:30,059
 적은이 알렉스 그물 같은 많은 많은 3 × 3 필터 

465
00:35:30,059 --> 00:35:35,119
 실제로 내가 생각 꽤 공통되고있다 작은 필터와 다른 것은 

466
00:35:35,119 --> 00:35:38,829
 당신을 네킹 한 병 하나의이 아이디어는 볼 구글의 두 버전에서 

467
00:35:38,829 --> 00:35:42,579
 되지도 ResNet에서 그것은 실제로 당신이 매개 변수를 많이 절약 할 수 있습니다 I 

468
00:35:42,579 --> 00:35:46,340
 이 염두에 두어야 할 유용한 트릭과 인수 분해의이 아이디어 생각 

469
00:35:46,340 --> 00:35:50,890
 내가 생각이 비대칭 필터로 회선 어쩌면 너무 광범위하지 않습니다 

470
00:35:50,889 --> 00:35:54,629
 지금 사용하지만, 더 일반적으로 미래에 사용되는 잘 모르겠어요 될 수 있습니다 

471
00:35:54,630 --> 00:36:00,160
 이러한 모든 트랙에 대한 지배적 인 테마를 통해 기본은 당신을 할 수 있다는 것입니다 

472
00:36:00,159 --> 00:36:04,289
 적은 학습 가능 매개 변수 적은 적은 컴퓨팅 등을 가지고 

473
00:36:04,289 --> 00:36:07,739
 좋은 기능을 모든 종류의 당신의 아키텍처를 데있다 비선형 

474
00:36:07,739 --> 00:36:18,779
 이러한 이러한 이러한 회선 아키텍처 설계에 대한 질문으로 

475
00:36:18,780 --> 00:36:21,300
 그녀가 너무 분명 가져 

476
00:36:21,300 --> 00:36:26,340
 확인 그래서 그 다음 것은 당신이했습니다되면 실제로 당신이 원하는 방법에 대한 결정이다 

477
00:36:26,340 --> 00:36:30,760
 회선의 스택을 묶는 당신은 실제로 그들을 계산하고이하는 

478
00:36:30,760 --> 00:36:33,630
 실제로 구현하는 여러 가지 방법에 많은 일이있었습니다 

479
00:36:33,630 --> 00:36:37,950
 기부는 우리가 루프를 사용하여 과제의 구현을 물어 

480
00:36:37,949 --> 00:36:43,960
 당신은 너무 잘 확장되지 않습니다 추​​측 수 있으므로이 너무 예쁜 예쁜 

481
00:36:43,960 --> 00:36:47,720
 구현하기가 매우 쉽다 쉬운 방법은 이름의이 아이디어는 호출하는 것입니다 

482
00:36:47,719 --> 00:36:52,269
 방법은 그래서 여기 직관은 우리가 행렬 곱셈 정말 알고있다 

483
00:36:52,269 --> 00:36:56,809
 빠르고 거기에 누군가가 거의 모든 컴퓨팅 아키텍처 

484
00:36:56,809 --> 00:37:00,949
 정말 정말 잘 최적화 행렬 곱셈 고정 라이브러리를 작성 

485
00:37:00,949 --> 00:37:06,230
 그래서 전화를 그의 생각이 잘 행렬 곱셈이 주어진 악취된다 

486
00:37:06,230 --> 00:37:07,400
 정말 빠른 

487
00:37:07,400 --> 00:37:11,420
 우리는이 컨볼 루션 연산을하고 같은 개주 수있는 몇 가지 방법이있다 

488
00:37:11,420 --> 00:37:17,800
 행렬 곱셈과 이것이 꽤 다소 쉽게가 있음을 밝혀 

489
00:37:17,800 --> 00:37:22,930
 아이디어가 그래서 당신은 우리의 입력 볼륨을 가지고 그것에 대해 생각하면 

490
00:37:22,929 --> 00:37:28,549
 바다 HIW 우리는 컨볼 루션 필터 회선의 필터 뱅크가 

491
00:37:28,550 --> 00:37:32,730
 그것은이 때문에 이들 각각 볼 볼륨으로 사례 별을 될 것입니다 

492
00:37:32,730 --> 00:37:36,659
 사례 별 수용 필드와 적응 두가 일치 일치 참조 

493
00:37:36,659 --> 00:37:39,989
 입력 여기에 우리는거야 것은 이러한 필터 처리해야하고 우리가 원하는 

494
00:37:39,989 --> 00:37:44,809
 아이디어는 점이다 있도록 행렬 곱셈 문제로이 점을 켭니다 

495
00:37:44,809 --> 00:37:48,829
 우리는 우리가 먼저 수용 필드를 취할려고하고 자신의 일을하는거야 

496
00:37:48,829 --> 00:37:54,019
 거 지역에서 CEE 영역에 의해 케이하여이 케이를 할 수있는 이미지의 

497
00:37:54,019 --> 00:37:58,130
 축구에서 최종까지 나는 사건이 컬럼에 그것을 바꿀거야 당신 

498
00:37:58,130 --> 00:38:01,910
 이에 요소를 확인하고 우리는 가능한 모든이를 반복하는거야 

499
00:38:01,909 --> 00:38:05,909
 이미지의 수용 필드 그래서 우리는 내가 갈거야이 작은 사람을거야 

500
00:38:05,909 --> 00:38:09,359
 이미지에 가능한 모든 영역에 걸쳐 그를 이동하고 여기에 그냥 말하는거야 

501
00:38:09,360 --> 00:38:12,680
 될 것이 아마 지역과 다른 수용 필드를 종료하는 것이 

502
00:38:12,679 --> 00:38:18,389
 위치는 지금 우리는 우리의 이미지를 촬영했습니다 우리는이 거대한으로 재편 촬영했습니다 

503
00:38:18,389 --> 00:38:25,139
 매트릭스 오 누구나 볼 볼 수있다 내 말 및 내 경우 어떤 가능성을 

504
00:38:25,139 --> 00:38:28,139
 이 아마와 문제 

505
00:38:28,139 --> 00:38:36,829
 그래, 그게 사실은 그래서 최선이 바로 많은 메모리를 많이 사용하는 경향이 

506
00:38:36,829 --> 00:38:41,380
 이 책의 요소가 나타나는 경우 여러 수용 필드 다음이다 

507
00:38:41,380 --> 00:38:45,010
 가고 그래서 이러한 열 여러 중복되는 및이에 가고 

508
00:38:45,010 --> 00:38:49,220
 당신의 수용 필드하지만 사이가 overlap은 더 더를 얻을 수 

509
00:38:49,219 --> 00:38:52,839
 실제로이 실제로 거래의 너무 큰 아니에요 및 밝혀 그 

510
00:38:52,840 --> 00:38:57,910
 우리는거야이 길쌈에 유사한 검사를 잘 실행하고 작품 

511
00:38:57,909 --> 00:39:01,699
 필터는 그래서 만약 당신이 회선 우리가 먹고 싶어 무엇을하고 있는지 기억 

512
00:39:01,699 --> 00:39:06,039
 이러한 길쌈 무게의 각 각으로 우리의 제품을 

513
00:39:06,039 --> 00:39:10,889
 이미지 때문에 각 수용 필드 위치에 대한 길쌈 무게 

514
00:39:10,889 --> 00:39:16,420
 이 길쌈 무게의 각이 케이에 의해이 케이 것은 좌석이 그렇게 대답 구입 

515
00:39:16,420 --> 00:39:21,059
 우리는 치로로 이제 우리는 D를 경우로 그 각각을 바꿀거야 

516
00:39:21,059 --> 00:39:26,420
 좌석 행렬은 지금이 좋은해진다 필터 그래서 우리는 경우에 의해 계약을 얻었다 

517
00:39:26,420 --> 00:39:31,750
 지금이 가이드는 수용 필드로 각 열의 모든 레셉 각을 포함 우리 

518
00:39:31,750 --> 00:39:37,039
 이미지에 하나의 컬럼 수용 필드가 지금이 행렬은 하나가있다 

519
00:39:37,039 --> 00:39:42,679
 하나의 각 행은 우리가 쉽게이 모든 계산할 수 해주기 때문에 다른 무게 

520
00:39:42,679 --> 00:39:49,069
 내부의 제품은 한 번에 하나의 행렬 곱 나는 사과 

521
00:39:49,070 --> 00:39:52,809
 이러한 차원의 아마 교체해야 밖으로 작동하지 않는 것은 더 만드는 것입니다 

522
00:39:52,809 --> 00:39:59,219
 분명하지만 난 당신이 아이디어를 얻을 생각 때문에이이 최종 결과에 의해 싶게를 제공하는 

523
00:39:59,219 --> 00:40:03,659
 그 D 출력 필터의 우리의 수를하고, n은 모두 받아 들일입니다 

524
00:40:03,659 --> 00:40:07,469
 이미지 필드의 위치는 다음이 걸릴 비슷한 여행을 재생 

525
00:40:07,469 --> 00:40:13,000
 실제로이 참을 수있는 실내 3D 전채로 모양을 변경 

526
00:40:13,000 --> 00:40:16,219
 아주 쉽게 당신이 이들의 미니 배치가있는 경우 너무 많은 배치 

527
00:40:16,219 --> 00:40:24,099
 요소는 당신은 행의 한 세트 나 다시 요소이 당 더 많은 행과 방법을 추가 

528
00:40:24,099 --> 00:40:28,589
 실제로 그래 그렇게 구현하는 매우 간단합니다 

529
00:40:28,590 --> 00:40:35,090
 그 것을 - 그 다음 구현 오른쪽에 달려 있지만, 다음의 따라 달라집니다 

530
00:40:35,090 --> 00:40:39,910
 그 때로는 같은 메모리 레이아웃 및 물건 같은 것들에 대해 걱정할 필요가 

531
00:40:39,909 --> 00:40:45,099
 당신도 당신이 병렬로 그것을 할 수있는 GPU에서 그 모양 변경 작업을 수행하지만, 

532
00:40:45,099 --> 00:40:50,089
 그래서 이것은 정말 쉬운 사례 연구로는 너무 많이 구현하는 등의 경우 경우 경우 

533
00:40:50,090 --> 00:40:53,470
 사용 가능한 컨벌루션 기술이 없어 하나를 구현해야 

534
00:40:53,469 --> 00:40:57,869
 이것은 아마도 선택할 수있는 하나 통과하면 실제 카페를 보면 

535
00:40:57,869 --> 00:41:01,119
 카페의 이전 버전이 그들이 무엇에 사용되는 방법이다 

536
00:41:01,119 --> 00:41:07,730
 기부금이는 GPU 충돌에 대한 회선 앞으로 코드가 있도록 

537
00:41:07,730 --> 00:41:12,630
 당신의 기본 GPU의 컨볼 루션들은으로 전화하는거야이 붉은 덩어리를 볼 수 있습니다 

538
00:41:12,630 --> 00:41:18,070
 전화를 같은 방법이 복용 그들의 입력 영상 권한을 가지고 그들의 

539
00:41:18,070 --> 00:41:22,900
 입력 영상 어딘가에이 그래서 이것은 그들의 의도 된 후 그들은거야 

540
00:41:22,900 --> 00:41:27,050
 이것은이이 방법으로 호출하고이를 저장하는 동일한 전화 재정비 

541
00:41:27,050 --> 00:41:33,519
 그들이 호출 곱 행렬 행렬에 거 가지고있어보다 열 GPU의 tenser 

542
00:41:33,519 --> 00:41:37,980
 즉, 그래서 그것은 곱셈 후 바이어스 행렬을 지속 할 수 

543
00:41:37,980 --> 00:41:42,840
 그 그 내가 이러한 일들이 실제로 아주 잘 작동하는 경향이 의미의 방법과 

544
00:41:42,840 --> 00:41:45,850
 당신은 우리가 당신 하나를 준 빠른 레이어를 기억한다면 또 다른 사례 연구가 

545
00:41:45,849 --> 00:41:51,500
 과제 실제로 우리가 실제로 나노 수행 그래서 여기에이 동일한 전략을 사용 

546
00:41:51,500 --> 00:41:55,940
 작업을 호출하는 지금 우리가 실제로 할 수있는 다음 어떤 미친 NumPy와 트릭이었고, 

547
00:41:55,940 --> 00:42:00,230
 NumPy와 매트릭스에 단일 통화와 FAST 층 내부의 회선 

548
00:42:00,230 --> 00:42:03,900
 곱셈 당신과이 보통 나에게 몇 가지를 제공합니다 숙제에 서명 

549
00:42:03,900 --> 00:42:07,740
 이 꽤 잘 작동 루프를 사용하는 것보다 더 빨리 백 번 

550
00:42:07,739 --> 00:42:18,209
 그리고는 전화 그에 대해 질문을 구현하는 데 아주 쉽게이다 

551
00:42:18,210 --> 00:42:24,949
 그것에 대해 조금 생각하지만, 당신이 생각하는 경우에 당신이 정말 열심히 생각하면 당신은거야 

552
00:42:24,949 --> 00:42:28,219
 컨볼 루션의 뒤로 패스도 실제로 실현 

553
00:42:28,219 --> 00:42:33,358
 당신이 그것에 대해 생각한다면 당신은 몇 가지 알아 낸 수 컨볼 루션 

554
00:42:33,358 --> 00:42:37,269
 당신의 숙제하지만 이전 버전과는 회선도 실제로의 유형입니다 통과 

555
00:42:37,269 --> 00:42:41,070
 상류 구배를 통해 실제로 비슷한을 사용할 수있는 이상 컨볼 루션 

556
00:42:41,070 --> 00:42:45,789
 담배가 아니라 유일한 트릭을 전달하기위한 이미지의 유형은 메소드를 호출합니다 

557
00:42:45,789 --> 00:42:51,259
 당신이 뒤로 패스 할 후에는 일부 그라디언트에 필요 한 것입니다 

558
00:42:51,260 --> 00:42:54,940
 상류에서 수용 필드를 중복 통해 당신은주의해야하므로 

559
00:42:54,940 --> 00:43:02,889
 통화 팀에 대해 당신이 뒤로 패스에서 호출 팀을 소환 필요 

560
00:43:02,889 --> 00:43:06,150
 숙제는 것을 구현에 실제로 빠른 차선에서 확인하실 수 있습니다 것은 

561
00:43:06,150 --> 00:43:11,050
 너무 실제로 비록 더 숙제를 호출 팀에 빠른 레이어 

562
00:43:11,050 --> 00:43:18,910
 실제로 거기에 내가 충분히 빨리 그것을 얻을 수있는 방법을 찾을 수 없습니다에 눈에 

563
00:43:18,909 --> 00:43:22,710
 때로는 사람들이 회선 사용하고는이 아이디어 또 다른 방법 

564
00:43:22,710 --> 00:43:27,400
 당신이 신호 등으로부터 추억이있는 경우 고속 푸리에 그래서 변환 

565
00:43:27,400 --> 00:43:30,700
 처리 클래스 또는 호출이 일을 기억 수도 같은 

566
00:43:30,699 --> 00:43:34,639
 충족 회선 정리는 두 개의 신호를 가지고 있다면 당신은 당신이 원하는 것을 말한다 

567
00:43:34,639 --> 00:43:38,779
 하나 신중하게 한 후 다른 여자와 계속되어 그들에게 전화 

568
00:43:38,780 --> 00:43:44,130
 이들 두 신호의 콘볼 루션을 복용하면 오히려와 동일 

569
00:43:44,130 --> 00:43:47,820
 회선의 푸리에 변환은 요소 제품과 동일 

570
00:43:47,820 --> 00:43:51,859
 당신은 당신이 밖으로 압축을 푼 가지고 기호를 응시 그래서 만약 푸리에 변환 I 

571
00:43:51,858 --> 00:43:56,779
 이 의미가있을 거라 생각하고 또한 경우 다시 신호에서 기억하고 있습니다 

572
00:43:56,780 --> 00:44:00,240
 처리 클래스 또는 알고리즘 클래스 호출이 놀라운 일이있다 

573
00:44:00,239 --> 00:44:04,299
 고속 푸리에 실제로 좋아 푸리에 변환을 계산하기 위해 우리가 할 수 변환 

574
00:44:04,300 --> 00:44:08,080
 역 푸리에 정말 정말 빠른 변환 변환 

575
00:44:08,079 --> 00:44:11,679
 당신은 2D에서 하루에이 버전의 곰 볼 수 있으므로 그들은 모든 것 

576
00:44:11,679 --> 00:44:17,129
 정말 빠른 그래서 우리는 실제로 엄격한 회선을 적용 할 수있는 방법이 너무 

577
00:44:17,130 --> 00:44:20,660
 작동 처음 우리가 고속 푸리에 변환을 사용하여 계산하는거야 것입니다 

578
00:44:20,659 --> 00:44:24,899
 푸리에 푸리에을 계산에도 가중치를 계산하는 변환 

579
00:44:24,900 --> 00:44:30,320
 우리의 활성화지도의 변환 지금 푸리에 공간에서 우리는 단지 요소를 할 

580
00:44:30,320 --> 00:44:35,050
 정말 정말 빠르고 효율적이며 다음 우리가 올 곱셈 

581
00:44:35,050 --> 00:44:40,269
 다시의 패스를 사용하여 상기 역 출력을 변환 할 변환 

582
00:44:40,269 --> 00:44:44,420
 그 요소 제품의이에 우리를 위해 회선을 구현 

583
00:44:44,420 --> 00:44:52,550
 멋진 영리한 방법 좀 시원하고이 실제로 사용하고 몇몇 사람에 직면하고있다 

584
00:44:52,550 --> 00:44:55,940
 페이스 북이 작년에 관한 논문을했다 그리고 그들은 실제로 출시 것을 

585
00:44:55,940 --> 00:44:57,650
 GPU 라이브러리는이 작업을 수행하는 

586
00:44:57,650 --> 00:45:03,329
 이 일을 계산하지만, 이러한 푸리에에 대한 슬픈 일이 변환이 

587
00:45:03,329 --> 00:45:07,819
 그들은 실제로 당신에게 정말 다른 방법하지만 통해 정말 큰 속도 향상을 제공 

588
00:45:07,820 --> 00:45:11,970
 당신은이 작은 3 × 3에 최선을 다하고 네 개의 큰 바위와 때 

589
00:45:11,969 --> 00:45:15,829
 푸리에 변환을 계산하는 오버 헤드를 향해 바로 변환 필터 

590
00:45:15,829 --> 00:45:20,449
 입력 화소 공간에서 직접 연산을하는 연산 

591
00:45:20,449 --> 00:45:25,579
 우리가 강의에 앞서 이야기로 작은 기여는 

592
00:45:25,579 --> 00:45:30,389
 그것은을, 그래서 많은 이유에 대해 정말 정말 멋지고 매력과 큰 

593
00:45:30,389 --> 00:45:33,489
 트릭이 너무 잘 영향을 작동하지 않습니다 수치의 조금 

594
00:45:33,489 --> 00:45:38,439
 우리하지만 어떤 이유로 경우 당신은 정말 큰 기여를 계산하고 싶어 

595
00:45:38,440 --> 00:45:46,019
 이 그래 당신이 시도 할 수있는 일입니다 

596
00:45:46,019 --> 00:46:02,489
 너무 물건에 관여하지만 당신이 문제가 아마이다 생각하면 내가 상상 

597
00:46:02,489 --> 00:46:04,639
 문제 

598
00:46:04,639 --> 00:46:12,900
 나중에 지적하는 또 다른 한가지는 그 푸리에에 대한 균형 아웃 한 종류의 

599
00:46:12,900 --> 00:46:17,430
 결론을 변환하는 것은 그들이 지금까지 너무 잘 월쯤 처리하지 않는다는 것입니다 

600
00:46:17,429 --> 00:46:21,219
 정상의 종류에 계산 귀에 거슬리는 회선과 일반 컴퓨터 

601
00:46:21,219 --> 00:46:25,409
 입력 공간 만 우리의 제품에 사람들의 작은 하위 집합을 계산하면 이렇게 

602
00:46:25,409 --> 00:46:28,489
 당신이 회선을 공격 할 때 실제로 계산을 많이 저장 

603
00:46:28,489 --> 00:46:32,199
 직접 입력 공간하지만 방법에 당신은 귀에 거슬리는 구현하는 경향이 

604
00:46:32,199 --> 00:46:36,649
 푸리에의 회선 공간이 당신은 단지 전체를 계산한다 변환 및 

605
00:46:36,650 --> 00:46:43,180
 그 때문에 매우 효율적되지 않는 끝, 그래서 당신은 데이터의 일부를 밖으로 던져 

606
00:46:43,179 --> 00:46:47,969
 정말 너무 넓게 생각도하게되지 않은 또 다른 트릭이있다 

607
00:46:47,969 --> 00:46:51,989
 알려진 아직하지만 난 정말 그렇게 내가 그것에 대해 그렇게 얘기하고 싶었 생각 좋아 

608
00:46:51,989 --> 00:46:55,909
 당신은 스트래튼의 알고리즘이라는 알고리즘 클래스에서 뭔가 기억하고있다 

609
00:46:55,909 --> 00:47:00,789
 바로 당신의 순진 행렬 곱셈을 수행 할 때 종료하는 것이이 아이디어가있다 

610
00:47:00,789 --> 00:47:04,869
 에 의해 종류의 행렬 당신은 카운트 경우 비록 모든 수정 있지만, 

611
00:47:04,869 --> 00:47:08,630
 당신이 그것을 할 필요가 추가는거야 어떤을 정도 걸릴 것 

612
00:47:08,630 --> 00:47:12,950
 귀여운 운영 및 스트래튼의 알고리즘은 정말 미친 것처럼 이것이다 우리 

613
00:47:12,949 --> 00:47:16,839
 이 모든 미친 중간체를 계산하고 어떻게 든 마술에 밖으로 작동 

614
00:47:16,840 --> 00:47:22,289
 순진한 방법보다 점근 적으로 빠른 출력을 계산하고 당신은 알고 

615
00:47:22,289 --> 00:47:26,869
 그 날 행렬 곱셈이 우리가 구현할 수있는 것을 알고 호출 

616
00:47:26,869 --> 00:47:31,339
 행렬 곱셈 같은 회선은 직관적으로 이러한 것을 예상합니다 

617
00:47:31,340 --> 00:47:35,110
 트릭 비슷한 유형의 이론적 아마에 적용 할 수 있습니다 

618
00:47:35,110 --> 00:47:41,320
 컨볼 루션 그것은 그들이 그렇게이 정말 멋진 용지가있을 수 있습니다 밝혀 그 단지 

619
00:47:41,320 --> 00:47:46,370
 이 두 사람이 아주 명시 적으로 밖으로 일 여름 동안 나왔다 

620
00:47:46,369 --> 00:47:50,670
 뭔가 아주 특별한 경우를 자주 암시 43 그것은이 포함됩니다 

621
00:47:50,670 --> 00:47:54,659
 분명 여기 세부 사항으로 이동하지 않을거야하지만 비슷한 맛이다 

622
00:47:54,659 --> 00:47:58,539
 스트레스와 중간 아주 영리한 계산에 

623
00:47:58,539 --> 00:48:03,630
 헨리 실제로 계산과 이들에 많이 저장을 결합 

624
00:48:03,630 --> 00:48:08,220
 사람은 실제로 정말 강렬하고 그들은 단지 수학자하지 않은 그들 

625
00:48:08,219 --> 00:48:11,959
 실제로 또한 매우 높은이를 계산하기위한 CUDA 커널을 최적화 쓴 

626
00:48:11,960 --> 00:48:17,570
 두 배 BGG을 단축 할 수 있었다 물건 그래서 정말 정말 

627
00:48:17,570 --> 00:48:21,890
 인상적인 그래서 나는이 이러한 유형의 트럭이 유형이 될 수 있다는 생각 

628
00:48:21,889 --> 00:48:26,019
 인 미래하지만 시간이 꽤 인기가 나는 그것이 매우 광범위하지 생각 

629
00:48:26,019 --> 00:48:30,650
 사용하지만이 숫자는 특히 그들이있어 작은 배치 크기에 미친 

630
00:48:30,650 --> 00:48:35,010
 그게 정말 인상적이고 I의의 BGG에 여섯 속도를 점점 

631
00:48:35,010 --> 00:48:38,770
 단점은 당신이 좀 일을해야한다는 것입니다 그것은 정말 멋진 방법이라고 생각 

632
00:48:38,769 --> 00:48:43,009
 이러한 명시 적으로 특별한 경우 외부 회선 각각 다른 크기 그러나 아마 

633
00:48:43,010 --> 00:48:45,850
 우리는 3 × 3 회선에 대해 신경 경우 그는 큰 문제가 아니다 

634
00:48:45,849 --> 00:48:54,719
 그래서 실제로 회선 컴퓨팅 정리해은 그 진짜의 종류 

635
00:48:54,719 --> 00:48:58,579
 이러한 것들을 구현하는 빠르고, 쉽고 신속하고 더러운 방법은 전화에서입니다 

636
00:48:58,579 --> 00:49:02,869
 행렬 곱셈이 전달됩니다 그것을 구현하는 것이 너무 어렵지 않다 않습니다 

637
00:49:02,869 --> 00:49:06,609
 이 것을 어떤 이유로 당신이 정말로 대회를 구현해야하는 경우 이렇게 

638
00:49:06,610 --> 00:49:11,400
 자신을 정말 통화 활동에 권 해드립니다은 오는 뭔가 

639
00:49:11,400 --> 00:49:15,230
 당신이 생각하는 신호 처리 정말 시원하고 정말 유용하지만 것 

640
00:49:15,230 --> 00:49:19,719
 그것은하지 그래서는하지만 큰 필터의 속도 업을 주는가 있다고 밝혀 

641
00:49:19,719 --> 00:49:24,000
 당신이 희망하지만 한 수만큼이 빠른 때문에 희망 유용있다 

642
00:49:24,000 --> 00:49:25,440
 알고리즘은 정말 좋아 

643
00:49:25,440 --> 00:49:29,650
 이미 세계 어딘가에 코드가 존재하고 필터는 그렇게 할 일 

644
00:49:29,650 --> 00:49:35,889
 희망이 이러한 것들에 잡아 더 널리 그래서 만약 사용 될 것입니다 

645
00:49:35,889 --> 00:49:41,529
 계산 회선에 대해 질문이있다 

646
00:49:41,530 --> 00:49:50,940
 확인을 우리는 첫 번째 질문 그래서 일부 구현 세부 사항에 대한 거 이야기를 그렇게 옆에있어 

647
00:49:50,940 --> 00:49:55,710
 어떻게 너희들은 지금까지 자신의 컴퓨터를 구축 할 

648
00:49:55,710 --> 00:50:01,710
 확인 그래서 너희들은 너무 사람이 할 수있는이 다음 슬라이드에이 답변 방지 할 수있다 

649
00:50:01,710 --> 00:50:07,869
 아웃 지점의 CPU 사람을 발견 

650
00:50:07,869 --> 00:50:17,210
 CPU는이 작은 사람이 바로 그래서 실제로는이 일이 사실이다 

651
00:50:17,210 --> 00:50:22,179
 는 CPU 자체의 내부에 약간의 작은 부분이 그래서 그것의 많은 쿨러입니다 

652
00:50:22,179 --> 00:50:28,730
 여기 많은 다음 스폿에게 GPU 냉각 방열판 실제로 

653
00:50:28,730 --> 00:50:38,320
 네, 그것은에 등이 GPU는 지포스를 말하는 것은 그것의 한 가지입니다입니다 

654
00:50:38,320 --> 00:50:43,180
 그것은 훨씬 더 큰 그리고 당신은 그래서 할 수 있습니다 있도록 CPU는 더 강력한 I하다 

655
00:50:43,179 --> 00:50:48,679
 알고 있지만 그 종류의 그, 그래서 적어도이 경우에 더 많은 공간을 복용 

656
00:50:48,679 --> 00:50:54,309
 흥미로운 일이 너무 일어나고 있다는 표시로 나는 또 다른 질문을하고 있는데 

657
00:50:54,309 --> 00:50:57,029
 당신 돼 플레이 비디오 게임 

658
00:50:57,030 --> 00:51:05,390
 확인 후, 당신은 아마 그래서 사람들이 많이 밝혀 이에 대한 의견 

659
00:51:05,389 --> 00:51:09,809
 기계 학습과 깊은 학습도 정말 강한 의견을 가지고 대부분의 

660
00:51:09,809 --> 00:51:15,639
 사람들은 그래서 엔비디아 실제로는 훨씬 더 널리 후 사용 측면에 있습니다 

661
00:51:15,639 --> 00:51:21,179
 AMD는 당신이 GPU는 미국을 사용하는 이유는 것입니다 

662
00:51:21,179 --> 00:51:25,599
 NVIDIA는 정말 정말 깊이로 다이빙 지난 몇 년에 많은 일을하고있다 

663
00:51:25,599 --> 00:51:30,710
 정도의 멋진 예를 들어 학습과 자신의 초점이 정말 핵심 부분 확인 

664
00:51:30,710 --> 00:51:34,769
 입니다 GTC에서 작년 

665
00:51:34,769 --> 00:51:39,869
 발표 새로운 제품에 대한 연간 큰 거대한 회의의 비디오 정렬 

666
00:51:39,869 --> 00:51:44,230
 비디오에서의 CEO 실제로 또한 스탠포드 경보입니다 젠슨 홍콩 

667
00:51:44,230 --> 00:51:49,059
 이 최신 가장 놀라운 새로운 GPU의 인두세 행위 등 소개 

668
00:51:49,059 --> 00:51:53,400
 자신의 주력 것은 그가 그것을 판매하는 데 사용되는 벤치 마크는 얼마나 빨리 

669
00:51:53,400 --> 00:51:56,800
 국가와 알렉스는 그렇게 만난이 미쳤다 

670
00:51:56,800 --> 00:52:00,140
 이 같은 수백 수백명의 사람들과 함께 거대한 방이었다 

671
00:52:00,139 --> 00:52:04,279
 이 거대한 높은 광택 프리젠 테이션 및 CEO 등 언론인과 

672
00:52:04,280 --> 00:52:07,890
 비디오에서 알렉스 그물 및 회선에 대해 얘기하고, 나는 그것이라고 생각했다 

673
00:52:07,889 --> 00:52:11,690
 정말 흥분하고 가지 방법을 보여줍니다 엔비디아는 정말 많은 약을 걱정하는 것이 

674
00:52:11,690 --> 00:52:15,300
 이 일을 얻는 것은 일을하고 그들에 노력을 많이 밀어하기 

675
00:52:15,300 --> 00:52:22,150
 그렇게 그냥 작동 제작에 들어가는 것은 아마 같은 생각을 당신에게 CPU를 제공합니다 

676
00:52:22,150 --> 00:52:26,900
 빠른 순차 처리에 정말 좋은 알고 그들은 작은을 갖는 경향이 

677
00:52:26,900 --> 00:52:31,019
 코어의 수는 노트북은 아마 어쩌면 사이에 하나 사처럼이 

678
00:52:31,019 --> 00:52:36,920
 서버의 모서리와 큰 일 최대 4분의 16과 이런 일이있을 수 있습니다 

679
00:52:36,920 --> 00:52:39,610
 컴퓨팅 물건 정말 정말 빨리에게 정말 좋은 

680
00:52:39,610 --> 00:52:45,349
 그리고 순서 GPU 반면에는 많은 많은 많은 과정을 갖는 경향 

681
00:52:45,349 --> 00:52:49,759
 세금 등 큰 사람은 분기 수천까지 가질 수 있지만 각 경향 

682
00:52:49,760 --> 00:52:53,500
 코어는 지난 2010년 5월 10일 낮은 클럭 속도를하고 당 더 적은을 할 수 있습니다 

683
00:52:53,500 --> 00:52:59,429
 이 GPU는 다시 우리가 실제로 처음으로 개발되었다 있도록 명령어 사이클 

684
00:52:59,429 --> 00:53:05,230
 처리 그래픽 그래픽 처리 장치는 그래서 그들은 일에 정말 좋은거야 

685
00:53:05,230 --> 00:53:09,699
 일종의 고도의 마비 작업은 싶어 많은 많은 일을 할 수 있습니다 

686
00:53:09,699 --> 00:53:15,460
 독립적으로 평행하고 원래 컴퓨터를 위해 설계 되었기 때문에 

687
00:53:15,460 --> 00:53:19,590
 그래픽은 그러나 그 이후 그들은 종류의보다 일반적인 컴퓨팅으로 진화했습니다 

688
00:53:19,590 --> 00:53:23,100
 당신이 쓸 수 다른 프레임 워크가 플랫폼 있도록 

689
00:53:23,099 --> 00:53:28,929
 엔비디아에서 우리는이 프레임 워크를 그래서 일반적인 코드는 GPU에서 직접 실행하기 

690
00:53:28,929 --> 00:53:33,509
 그것은 당신이 실제로 직접 실행되는 코드를 작성 시트의 변형을 작성할 수 있습니다 

691
00:53:33,510 --> 00:53:37,990
 GPU에서와에 작동 오픈 CL이라는 비슷한 프레임 워크가있다 

692
00:53:37,989 --> 00:53:43,569
 거의 모든 컴퓨팅 플랫폼 어느 정도하지만 개방형 표준이되는 의미 

693
00:53:43,570 --> 00:53:48,890
 좋은 그것은 OpenCL을 사방에 작동하는지 아주 좋다하지만 실제로는 그렇게 열 

694
00:53:48,889 --> 00:53:52,559
 즉, 더 많은 성능과 방법을 조금 더 멋진 도서관 경향이있다 

695
00:53:52,559 --> 00:53:57,420
 지원 적어도 네 깊은 학습 대부분의 사람들이 사용할 수 있도록 할 수 대신하고있는 경우 

696
00:53:57,420 --> 00:54:01,309
 실제로 G PIKO G PIKO를 직접 작성하는 방법을 학습에 관심 

697
00:54:01,309 --> 00:54:05,230
 나는 그것이 꽤 멋지다의 것 정말 멋진 불쾌한 과정이 재미 있어요 

698
00:54:05,230 --> 00:54:09,409
 당신이 코드는 GPU에 일을 실행에 쓸 수 있습니다 할당 모두 있지만, 

699
00:54:09,409 --> 00:54:12,730
 당신이 원하는 모든 경우 방법은 기차 너트를 와서 연구와 그와 같은 작업을 수행 

700
00:54:12,730 --> 00:54:16,409
 일의 당신은 일반적으로이 코드를 직접 당신이 중 하나를 작성하지 않아도 결국 

701
00:54:16,409 --> 00:54:20,139
 단지 외부 라이브러리에 의존 

702
00:54:20,139 --> 00:54:33,440
 바로 그렇게 할 수 나는이 너무 귀엽다이 원 이상 높은 수준의 도서관처럼 

703
00:54:33,440 --> 00:54:38,599
 종류의 유리 바로 그래서 한 가지 같은 GPU는에 정말 정말 좋은 것을 

704
00:54:38,599 --> 00:54:43,420
 행렬 곱셈은 그래서 여기 여기 난이 엔비디아의에서 인 벤치 마크 뜻이야 

705
00:54:43,420 --> 00:54:49,550
 웹 사이트는 그래서 조금 편견이다 그러나 이것은 행렬 곱셈을 보이고있다 

706
00:54:49,550 --> 00:54:54,789
 이 꽤 살이 찐 CPU에 매트릭스 눈의 함수로 시간은 12 군단의 사람입니다 

707
00:54:54,789 --> 00:55:00,079
 그것은 아주 아주 건강한 CPU처럼 서버에 살고있는 것이입니다 

708
00:55:00,079 --> 00:55:04,000
 를 인 40 같은 시험에서 곱셈 같은 날짜 과학 행렬을 실행 

709
00:55:04,000 --> 00:55:11,000
 꽤 살이 찐 GPU 그것은 훨씬 더 빨리 내가​​ 그 더 큰 놀라움 오른쪽 없습니다 의미이고 

710
00:55:11,000 --> 00:55:15,119
 당신이 언급 한 비디오는이되도록 GPU는 또한 정말 꼭 회선입니다 

711
00:55:15,119 --> 00:55:19,909
 오늘 호출 라이브러리는 특별히 최적화 된 낙관주의 CUDA를 발표했다 

712
00:55:19,909 --> 00:55:26,139
 회선에 대한 커널 그래서 내 말은 CPU에 비해​​ 그것은 WAY 빨리이의의 

713
00:55:26,139 --> 00:55:30,139
 실제로 그를 비교하는 것은 함께 캠페인의 기여를 호출 

714
00:55:30,139 --> 00:55:34,920
 승무원 티에 넨 회선 나는이 그래프는 처음부터 실제로 생각 

715
00:55:34,920 --> 00:55:41,030
 CNN 버전의 버전은 단지 몇 주 전에 나와서 그러나 이것은 단지입니다 

716
00:55:41,030 --> 00:55:44,600
 실제로 다음 벤치 마크 토목 때문에 CPU 벤치 마크했다 버전 

717
00:55:44,599 --> 00:55:49,699
 더 빨리 그 이후부터 많이있어, 그래서 나 이전 버전에 대해되었습니다 

718
00:55:49,699 --> 00:55:54,769
 여기에 있지만 증거가 맞는 방법은 두 개의 폭발 같은 또는 뭔가 

719
00:55:54,769 --> 00:56:00,090
 이 기능을 제공하고 단지 종류의 것을 볼 수 있도록 DNN은 C 라이브러리입니다 

720
00:56:00,090 --> 00:56:05,309
 C 라이브러리와 GPU 멀리 추상 그래서 당신은 일종의에서의 텐서이있는 경우 

721
00:56:05,309 --> 00:56:09,429
 메모리와 방금 한국 라이브러리에 대한 포인터를 전달할 수 있습니다보고는거야 

722
00:56:09,429 --> 00:56:13,299
 conf의 작은 아마 비동기 적으로 GPU에서 실행 돌아가서를 반환 

723
00:56:13,300 --> 00:56:19,440
 결과 카페와 토치와 같은 프레임 워크 있도록 모든 이제 Q의 티에 넨을 통합 한 

724
00:56:19,440 --> 00:56:23,750
 물건을 자신의 프레임 워크에 당신은 어떤에서 이러한 효율적인 솔루션을 활용할 수 

725
00:56:23,750 --> 00:56:30,340
 이 프레임 워크는 알고 있지만, 문제는 그 우리는이를 일단 경우에도 

726
00:56:30,340 --> 00:56:33,430
 정말 큰 모델을 훈련 강력한 GPU는 종류 여전히 

727
00:56:33,429 --> 00:56:39,409
 VG 정가가에 2 ~ 3 주 같은 훈련을 유명하게되었다 그래서 천천히 

728
00:56:39,409 --> 00:56:43,759
 타이탄 무엇 타이탄 블랙 샌들은 싸지 않다이었고, 그것은 실제로이었다 

729
00:56:43,760 --> 00:56:47,280
 ResNet의 추천은 최근이 최대 정말 멋진 바로 거기 

730
00:56:47,280 --> 00:56:51,839
 정말 멋진 블로그 게시물 여기를 설명하고 실제로 ResNet을 재교육 

731
00:56:51,838 --> 00:56:56,400
 백 한 레이어 모델과 또한 동안 훈련을 2 주 정도 걸렸다 

732
00:56:56,400 --> 00:57:03,880
 그 좋지 않다, 그래서 GPU를하고 한 방향으로 그 사람들이 길을 쉬운 방법으로 그 

733
00:57:03,880 --> 00:57:08,269
 당신의 돈을 돌려 걸쳐 분할되어 여러 GPU에 걸쳐 교육을 분할 

734
00:57:08,269 --> 00:57:14,230
 당신이 특히 BGG 같은 사람을 위해 당신이 수있는 GPU를 정상적으로 있도록 소요 

735
00:57:14,230 --> 00:57:17,679
 많은 메모리 그래서 당신은 매우 큰 나 배치 크기와 경쟁 할 수 

736
00:57:17,679 --> 00:57:23,649
 단일 GPU 당신은 당신이 할 거 야 그래서 어떤 이미지의 배치가 될 수있는 6 128 

737
00:57:23,650 --> 00:57:24,700
 그런 일 

738
00:57:24,699 --> 00:57:30,338
 네 개의 동일한 조각으로 어떤 경기보다 각각의 GPU는 순방향 및 역방향을 계산 

739
00:57:30,338 --> 00:57:35,190
 가중치 반면에 계산 pramit 구배에 많은 배치에 대해 통과 

740
00:57:35,190 --> 00:57:39,470
 GPU에 대한 후 모든 무게 당신의 일부 내부에 그 무게의 일부 

741
00:57:39,469 --> 00:57:44,548
 스페인어와이 정말 간단한 방법 즉 있도록 업데이 트 모델을 만드는 사람들 

742
00:57:44,548 --> 00:57:53,599
 그래 GPU에서 분포를 구현하는 경향이 

743
00:57:53,599 --> 00:57:59,089
 그들은이 과정을 자동화 할 수 있다고 주장 왜 그래 그래서 그건 및 

744
00:57:59,090 --> 00:58:03,039
 정말 정말 효율적으로 내가 생각하는 정말 흥분되는에게 배포하지만 

745
00:58:03,039 --> 00:58:07,820
 적어도 토치도 자신을 많이 연주되지 않은 데이터 병렬있다 

746
00:58:07,820 --> 00:58:11,059
 당신이 그냥 드롭과는 자동으로 모든 종류의 사용할 수있는 

747
00:58:11,059 --> 00:58:14,070
 병렬 이런 종류의 아주 쉽게 

748
00:58:14,070 --> 00:58:18,930
 멀티 GPU 훈련을위한 약간 더 복잡한 아이디어는 실제로 알렉스에서 온다 

749
00:58:18,929 --> 00:58:21,279
 알렉스되지 명성 

750
00:58:21,280 --> 00:58:26,670
 그 재미있는 제목의 멋진 가지 종류하지만 생각 생각하지만, 생각은 

751
00:58:26,670 --> 00:58:31,409
 우리는 실제로 하위 계층에 등을 데이터 병렬 처리를 수행하도록 

752
00:58:31,409 --> 00:58:35,980
 우리의 이미지를 여러 배치를 취할 것 하위 계층은 두 개의 GPU를 통해 분할 및 

753
00:58:35,980 --> 00:58:42,059
 먹고 GPU 하나는 먼저 첫 번째 부분에 대해 컨볼 루션을 계산하는 것 

754
00:58:42,059 --> 00:58:46,279
 많은 배치의 일부 단지 발표 그냥 빌려 컨볼 루션 부분이 될 것입니다 

755
00:58:46,280 --> 00:58:49,960
 GPU에 걸쳐 균등하게 분포하지만 당신이 일단 완전 연결 

756
00:58:49,960 --> 00:58:50,760
 층 

757
00:58:50,760 --> 00:58:54,800
 그는 당신이 정말 큰 매트릭스 경우 실제로 더 효율적 발견 

758
00:58:54,800 --> 00:58:58,810
 승산은 실제로 서로에 GPS 작업이 더 효율적 

759
00:58:58,809 --> 00:59:02,869
 매우 아니다이 행렬이 멋진 트랙의 종류 곱 계산 

760
00:59:02,869 --> 00:59:09,480
 일반적으로 사용하지만 그것이 구글에서 다른 생각을 언급하는 재미의 생각 

761
00:59:09,480 --> 00:59:13,800
 tenser 흐름이되기 전에 그들이이 일이라고했다 전에이다 

762
00:59:13,800 --> 00:59:18,380
 전체 CPU 기반이었다 자신의 이전 시스템이었다 불신 

763
00:59:18,380 --> 00:59:22,630
 몇 슬라이드 전에 벤치 마크에서 당신이 될 줄 상상도 할 수있는 

764
00:59:22,630 --> 00:59:26,250
 정말 느리지 만 실제로 구글 매트의 첫 번째 버전은 모든 훈련을했다 

765
00:59:26,250 --> 00:59:30,800
 CPU에 대한 불신 때문에 실제로 그래서 그들은 엄청난 양의 작업을 수행했다 

766
00:59:30,800 --> 00:59:35,800
 CPU에 분포는이 멋진 종이 거기에 이런 일이 그래서 여기에 훈련을받을 

767
00:59:35,800 --> 00:59:39,530
 이 설명 몇 년 전 JAP 청소년과 더 많은 세부 사항 만에서 

768
00:59:39,530 --> 00:59:43,640
 당신은 데이터 병렬 처리를 사용하거나 각 시스템이 독립적 인 복사본이 

769
00:59:43,639 --> 00:59:48,710
 데이터의 패치에 모델과 앞으로 컴퓨팅 각 기계 및 이전 버전 

770
00:59:48,710 --> 00:59:52,659
 하지만 지금은 당신이 실제로 저장있어이 매개 변수 서버가 텍스트 

771
00:59:52,659 --> 00:59:55,739
 모델의 매개 변수와 이러한 독립적 인 노동자 만들고있다 

772
00:59:55,739 --> 01:00:01,209
 파라미터 서버와의 통신 모델을 업데이트 할 수 있으며하도록 

773
01:00:01,210 --> 01:00:05,740
 당신이 1을 입력 어디 모델 병렬로이 대조 

774
01:00:05,739 --> 01:00:09,879
 모델 당신은의 다른 부분을 계산하는 다른 다른 노동자 

775
01:00:09,880 --> 01:00:14,650
 그래서 모델과 불신에 그들은 정말 정말 좋은 일을했다 

776
01:00:14,650 --> 01:00:18,110
 이 많은 많은 CPU와 많은 많은 걸쳐 정말 잘 작동하도록 최적화 

777
01:00:18,110 --> 01:00:23,170
 기계는하지만 지금은 희망이 일을해야 암의 흐름이 

778
01:00:23,170 --> 01:00:28,639
 더 자동으로 당신이 이러한 업데이트를하고있어 일단이있다 

779
01:00:28,639 --> 01:00:34,949
 비동기 STD 및 동기 STD 사이의 생각은 그래서 동기 STD입니다 

780
01:00:34,949 --> 01:00:39,299
 순진한 것 같은 것들 중 하나는 당신이 어떤 배치를 예상하면 

781
01:00:39,300 --> 01:00:42,880
 각 노동자는 다수의 근로자에​​ 걸쳐 전후 않습니다 분할 

782
01:00:42,880 --> 01:00:46,710
 당신은 모든 그라디언트를 추가하고 단일 모델을 그라데이션을 계산 

783
01:00:46,710 --> 01:00:51,220
 업데이트이이 정확하게의 정렬 시뮬레이션 할 것 

784
01:00:51,219 --> 01:00:55,029
 그냥 계산하지만 더 큰 기계에 많은 배치하지만 종류의 수 

785
01:00:55,030 --> 01:00:59,619
 당신이 기계를 통해 동기화 할 수 있기 때문에 속도가 느린 이것은 너무 많은 경향이있다 

786
01:00:59,619 --> 01:01:03,610
 단일 노트에 여러 GPU를 작업 만 한 번하고 큰 문제 

787
01:01:03,610 --> 01:01:08,430
 당신은 많은 많은 CPU를 통해 내가 동기있어 그 지역을 분산하고 

788
01:01:08,429 --> 01:01:12,569
 사실은 꽤 비쌀 수 있으므로 대신 적어도 그들은이있다 

789
01:01:12,570 --> 01:01:17,500
 각 모델은 단지 종류의 제조 업데이트 인 비동기 STD의 개념 

790
01:01:17,500 --> 01:01:21,599
 매개 변수의 복사본에 그는 몇 가지 개념이 

791
01:01:21,599 --> 01:01:25,480
 그들은 때로는 주기적으로 동기화 최종 일관성 

792
01:01:25,480 --> 01:01:29,530
 서로 그것의 디버그하지만 정말 복잡하고 어려운 것 같다 

793
01:01:29,530 --> 01:01:35,619
 그렇게 작동하려면 그것은 정말 멋진 그림 중 하나가 꽤 멋진이고있어 

794
01:01:35,619 --> 01:01:39,430
 그래서이 두 숫자는 텐서 흐름 종이 모두이며 하나 

795
01:01:39,429 --> 01:01:42,549
 텐서 흐름의 이미지는 실제로 이러한 유형해야한다는 것이다 

796
01:01:42,550 --> 01:01:46,510
 당신이 일어날 경우 그 사용자에게 훨씬 더 투명 유통 

797
01:01:46,510 --> 01:01:51,580
 의 GPU와 CPU를 큰 클러스터에 액세스하고 이것 저것 tenser 흐름해야 

798
01:01:51,579 --> 01:01:54,840
 자동으로 이러한 종류의 할 수있는 최선의 방법을 알아낼 수 

799
01:01:54,840 --> 01:01:58,970
 데이터 및 모델의 병렬 처리와 결합 분포는 당신을 위해 모든 것을 할 

800
01:01:58,969 --> 01:02:03,399
 즉 그것은 정말 멋진이고, 그래서 나는 그게 정말 흥미로운 부분이라고 생각 

801
01:02:03,400 --> 01:02:11,050
 바보 훈련 약 1000 어떤 질문이 그래 

802
01:02:11,050 --> 01:02:16,120
 및 CN TK 나는 아직 그것을 살펴 촬영하지 않은 

803
01:02:16,119 --> 01:02:22,130
 확인 그래서 다음 번에 ​​몇 병목 현상은 당신이 알고 있어야 거기 

804
01:02:22,130 --> 01:02:27,500
 연습은 그래서 일반적으로이 같은이 일을 훈련 할 때처럼 기대 

805
01:02:27,500 --> 01:02:30,769
 분산 물건 좋은 큰하지만 당신은 실제로 단지와 함께 먼 길을 갈 수 있습니다 

806
01:02:30,769 --> 01:02:34,840
 하나의 단일 시스템에 GPU 및 병목 현상이 많이있다 그 

807
01:02:34,840 --> 01:02:39,160
 그런데 하나 얻을 수 것은 GPU와 CPU 사이의 통신이며 

808
01:02:39,159 --> 01:02:44,759
 실제로 그리고 많은 경우, 데이터는 가장 작고, 특히 

809
01:02:44,760 --> 01:02:48,000
 파이프 라인의 고가의 제품은 GPU에 다음의 데이터를 복사하는 

810
01:02:48,000 --> 01:02:51,579
 당신은 GPU에서 일을 일단 당신이 할 수있는 다시 복사 

811
01:02:51,579 --> 01:02:55,719
 계산 정말 정말 빠르고 효율적으로하지만 복사는이다 

812
01:02:55,719 --> 01:03:01,089
 정말 느린 부분은 메모리 복사를 방지 할 수 있는지 확인하려면로 11 아이디어 그래서 

813
01:03:01,090 --> 01:03:06,570
 같은 때때로 네트워크의 각 계층에서 모두 표시 한 것입니다 

814
01:03:06,570 --> 01:03:10,460
 CPU에 GPU에서 앞뒤로 복사하고 정말 비효율적이고 속도가 느려질 수 있습니다 

815
01:03:10,460 --> 01:03:14,170
 그래서 이상적으로 모든 것을 아래로 실행하기 위해 앞으로 전체와 후방 패스를 할 

816
01:03:14,170 --> 01:03:17,159
 GPU에에 한 번 

817
01:03:17,159 --> 01:03:21,139
 당신이 볼 수있는 곳 가끔 볼 수 있습니다 또 다른 한가지는 접근 방식을 다중 스레드 

818
01:03:21,139 --> 01:03:27,849
 에 하나의 스레드에서 데이터 많은 메모리를 프리 페치 된 CPU 스레드 

819
01:03:27,849 --> 01:03:28,690
 배경 

820
01:03:28,690 --> 01:03:34,070
 아마도 온라인 보강을 임명하고이이 배경 CPU 

821
01:03:34,070 --> 01:03:37,470
 전역 종류의를 발송도 가능 나에게 배치를 준비 할 것 

822
01:03:37,469 --> 01:03:41,669
 이상 GPU에 당신은 종류의 데이터와 컴퓨팅이로드를 조정할 수 있습니다 

823
01:03:41,670 --> 01:03:44,680
 전처리 및 배송 메모리 배송 

824
01:03:44,679 --> 01:03:48,940
 많은 배치 데이터를 GPU에 실제로 계산을하고 실제로 

825
01:03:48,940 --> 01:03:51,980
 아주 약간의 구애에 참여할 수 난의 모든 것을 알 수있을 것입니다 

826
01:03:51,980 --> 01:03:57,719
 멀티 스레드 방식으로 나는 특히 카페 있도록 당신에게 좋은 속도 향상을 제공 할 수 있습니다 

827
01:03:57,719 --> 01:04:01,059
 나는 이미 생각 특정 거기에이 프리 페치 날짜를 구현 

828
01:04:01,059 --> 01:04:04,199
 데이터 스토리지 및 기타 프레임 워크의 유형 당신은 롤이 당신의 

829
01:04:04,199 --> 01:04:11,839
 또 다른 문제는 CPU 디스크 모델 Mac 그래서이 이러한 일들이 친절이다 소유 

830
01:04:11,840 --> 01:04:17,820
 느린 그들은 저렴하고있어 그들은 큰이야하지만 그들은 실제로 그렇게 그렇게 가장하지 않습니다 

831
01:04:17,820 --> 01:04:22,220
 이제 이러한 고체 드라이브는 훨씬 더 일반적인 하드 디스크이다 

832
01:04:22,219 --> 01:04:25,730
 그러나 문제는 고체 상태 드라이브는 더 작고 비용이 알고있는 것이다 

833
01:04:25,730 --> 01:04:30,590
 하지만 그들은 실제로 많이 익숙해 빨리 너무 많이 그래서 무슨 일이 정말이야 

834
01:04:30,590 --> 01:04:35,710
 비록 하드 디스크 및 고체 상태 드라이브와 같은 양으로 하나 하나 공통점 

835
01:04:35,710 --> 01:04:39,889
 당신이 그렇게 책상을 많이 떨어져 데이​​터를 순차적으로 읽고있는 때 가장 잘 작동 

836
01:04:39,889 --> 01:04:44,108
 예는 정말 나쁜 것 당신이 바로 그렇게 한 일을하는지 번 

837
01:04:44,108 --> 01:04:48,569
 이제 이러한 이미지를 각각 때문에 JPEG 이미지의 전체 큰 폴더를해야합니다 수 

838
01:04:48,570 --> 01:04:52,309
 그것까지 정말이 될 수 있도록 책상에 다른 부분에 위치 할 

839
01:04:52,309 --> 01:04:56,619
 임의의 사용자가 읽어도 일단 지금은 개별 JPEG 이미지를 읽어 추구하고 

840
01:04:56,619 --> 01:05:01,150
 JPEG는 그렇게 무엇을 매우 비효율적 그 픽셀에 압축을 해제해야 

841
01:05:01,150 --> 01:05:05,079
 당신은 연습에 많은 시간이 표시됩니다 당신거야 실제로 처리기 데이터가 

842
01:05:05,079 --> 01:05:10,059
 그것을 압축 해제 단지 전체 데이터를 하나에 앉아 원시 픽셀을 타고 

843
01:05:10,059 --> 01:05:15,940
 그래서 책상에 거대한 연속 파일이 디스크 공간을 많이 걸리지 만 우리가 할 

844
01:05:15,940 --> 01:05:22,230
 그것은 어쨌든 그것은 평온의 좋은 모든 때문에 바로 그래서 이것은 좀 너무하다 

845
01:05:22,230 --> 01:05:27,400
 카페에서 우리가 할 레벨 D 등을 결합하여이 작업을 수행하는 것은 일반적으로 사용되는 하나입니다 

846
01:05:27,400 --> 01:05:33,599
 형식은 또한 나 또한 HTML5를 사용하는 사용하는 우리를 위해 많은 파일하지만 아이디어는 것입니다했습니다 

847
01:05:33,599 --> 01:05:39,280
 당신은 모든 순차적으로 책상에 이미 설정 데이터 싶어 

848
01:05:39,280 --> 01:05:43,180
 픽셀 상원 훈련에 당신은 당신이 모든 데이터를 저장할 수있는 훈련 할 때 

849
01:05:43,179 --> 01:05:46,230
 메모리 당신은 당신이 그 빠른 속도로 읽을 만들고 싶어 할 때 책상을 읽을 필요 

850
01:05:46,230 --> 01:05:50,679
 프리 페의 영리한 금액과 멀티 스레드 물건을 다시 가능하고 

851
01:05:50,679 --> 01:05:54,829
 당신은 당신이 원 다른 동안 최고 책상 투구 소중히 수도있을 수 있습니다 

852
01:05:54,829 --> 01:05:57,460
 경쟁은 백그라운드에서 일어나는 

853
01:05:57,460 --> 01:06:05,019
 GPU가 큰 사람은 그래서 기억해야 할 또 다른 점은 GPU 메모리 병목 현상입니다 

854
01:06:05,019 --> 01:06:10,559
 큰 사람은 많은 메모리를 가지고 있지만 그 정도의 가장 큰 GPU는 그래서 당신은 할 수 있습니다 

855
01:06:10,559 --> 01:06:15,539
 지금 내가 세금 것을 구입하고 키 마흔 메모리 12 기가를 가지고 그건 

856
01:06:15,539 --> 01:06:18,139
 당신이 지금받을거야으로 큰로서 꽤 많은 

857
01:06:18,139 --> 01:06:22,679
 NextGen 더 큰해야하지만 실제로는이 제한에 반대 충돌 할 수 있습니다 

858
01:06:22,679 --> 01:06:26,989
 당신은 BG 또는 같은 것을 훈련하고 특히 너무 많은 문제없이 

859
01:06:26,989 --> 01:06:31,608
 당신이 발생하는 경우 재발 네트워크는 매우 매우 매우 매우 긴 시간이 그것의 중지했다 

860
01:06:31,608 --> 01:06:34,929
 실제로 뭔가가있어이 메모리 제한에 반대 충돌하지 너무 열심히 

861
01:06:34,929 --> 01:06:35,598
 유지해야 

862
01:06:35,599 --> 01:06:39,130
 당신이 알고에 대해 당신이이 비행기의 일부를이 일을 훈련하고있을 때 마음 

863
01:06:39,130 --> 01:06:43,450
 이러한 효율적인 회선 실제로 영리하게 만드는 구조 

864
01:06:43,449 --> 01:06:47,068
 당신이 더 큰 더 강력한 모델을 가지고 할 수있는 경우뿐만 아니라이 메모리에 도움 

865
01:06:47,068 --> 01:06:52,268
 와 적은 양의 메모리를 적게 사용하지 않는 당신은 훈련 할 수 있습니다보다 

866
01:06:52,268 --> 01:06:58,129
 일이 더 빠르고 더 큰 일치를 사용하고 모든 것이 좋고, 다만 단지 

867
01:06:58,130 --> 01:07:01,588
 규모 알렉스 기사의 의미는 모델의 많은에 비해 매우 작다 

868
01:07:01,588 --> 01:07:05,608
 이미 소요 256 다시 양쪽 이제 최첨단하지만 알렉스 그물이 있습니다 

869
01:07:05,608 --> 01:07:09,469
 대한 3기가바이트 GB 메모리 당신은 그것의이 더 큰 네트워크가 한 번 있도록 

870
01:07:09,469 --> 01:07:15,738
 실제로 그래서 다른 일이 12 월 12 한계에 부딪하지 너무 열심히 우리 

871
01:07:15,739 --> 01:07:20,978
 나는 많은 코드를 작성하고있을 때 너무 소수점 정밀도를 떠 대해 이야기한다 

872
01:07:20,978 --> 01:07:24,788
 시간의 나는 당신이 이러한 일들이 그냥 실수 알고 상상하기 좋아하고 

873
01:07:24,789 --> 01:07:27,960
 그들은 단지 작동하지만 실제로 그것은 사실이 아니에요 당신은 생각해야 

874
01:07:27,960 --> 01:07:32,889
 부동 소수점의 얼마나 많은 비트 같은 것들 때문에 대부분의 유형을 사용하는 

875
01:07:32,889 --> 01:07:37,159
 당신이 일종의 작성할 수 있습니다 숫자 코드의 유형이 많이 이중으로되어 있습니다 

876
01:07:37,159 --> 01:07:43,278
 또한 작성의 기본이에 의해 정밀 64 비트를 많이 사용하고 더 

877
01:07:43,278 --> 01:07:47,449
 이것은 단지 그래서 일반적으로 깊은 학습에 사용되는 단일 정밀도의이 아이디어는 

878
01:07:47,449 --> 01:07:52,710
 32 내기 때문에 아이디어는 각 번호는 다음 적은 베팅 걸리는 경우 당신이 할 수있는 그 

879
01:07:52,710 --> 01:07:56,469
 그 좋은, 그래서 같은 양의 메모리 내에서 그 숫자를 더 저장하고 

880
01:07:56,469 --> 01:08:00,559
 또한 적은 베팅으로 당신은 더 적은 계산하여이야 그 숫자에서 작동해야 

881
01:08:00,559 --> 01:08:05,210
 또한 우리는 그들이이기 때문에 작은 데이터 유형이 좋은 싶습니다 일반적 있도록 

882
01:08:05,210 --> 01:08:11,150
 빠른 계산하고 불필요한 메모리와 케이스 등의 연구로이 있었다 

883
01:08:11,150 --> 01:08:15,489
 실제로 숙제에 심지어 문제는 그과를 눈치 챘을 수 있도록 

884
01:08:15,489 --> 01:08:16,960
 기본 데이터 타입이있다 

885
01:08:16,960 --> 01:08:21,289
 64 비트 배정 밀도하지만 우리가 당신을 제공하는이 모델의 모든 

886
01:08:21,289 --> 01:08:25,789
 숙제 우리는이 캐스트 또는 32 비트 부동 소수점 숫자를 가지고 있었고, 당신은 할 수 

887
01:08:25,789 --> 01:08:28,670
 실제로 숙제에 돌아가서이 두 당신은거야 사이를 전환 시도 

888
01:08:28,670 --> 01:08:32,908
 32 비트로 전환하는 것은 실제로 당신에게 몇 가지 괜찮은 몇 가지를 제공합니다 볼 

889
01:08:32,908 --> 01:08:39,670
 괜찮은 속도 업 그렇게 나쁜 명백한 문제는 그 32 베팅이 더 나은 경우 

890
01:08:39,670 --> 01:08:42,829
 64 내기 아마 지출보다 우리는 이하를 사용할 수 있습니다 

891
01:08:42,829 --> 01:08:52,199
 그래서이 권리가있다 

892
01:08:52,199 --> 01:09:01,010
 16 베팅은 있지만 32 비트뿐만 아니라, 그래서이 큰 확인을 수행하도록 명령했다 

893
01:09:01,010 --> 01:09:05,420
 부동 소수점 16 비트 부동 소수점에 대한 표준도있다 

894
01:09:05,420 --> 01:09:09,699
 때로는 반 정밀도와 cunanan 실제로 최신 버전이 할라고 

895
01:09:09,699 --> 01:09:17,199
 멋진 실제로 거기에있는 위치에서 지원 컴퓨팅 것들 

896
01:09:17,199 --> 01:09:20,050
 라는 회사에서 다른 기존의 구현 

897
01:09:20,050 --> 01:09:23,850
 이러한 그래서이 여섯 비트 구현되는이 자신의 바나 

898
01:09:23,850 --> 01:09:28,350
 이 좋은 GET있다이 때문에 지금 거기에 가장 빠른 회선 

899
01:09:28,350 --> 01:09:31,850
 다른 유형의 주석 벤치 마크의 종류가 배고픈 설문 조사 

900
01:09:31,850 --> 01:09:35,160
 회선 및 프레임 워크 및 모든과 거의 모든의 

901
01:09:35,159 --> 01:09:38,319
 우승이 모든 벤치 마크 지금이 16 비트 부동 소수점입니다 

902
01:09:38,319 --> 01:09:42,279
 난 당신이 가질 수 있기 때문에 놀라운 일이 옳지 않다 너바나에서 작업 

903
01:09:42,279 --> 01:09:47,479
 베팅 더 빨리, 그래서 경쟁하지만 지금 아직 사실이 아니다합니다 

904
01:09:47,479 --> 01:09:51,479
 열 여섯 비트를 이용하기위한 카페 또는 토치 같은 것들에 프레임 워크 지원 

905
01:09:51,479 --> 01:09:57,299
 계산하지만 곧 다가오는되어야하지만, 문제는 우리하더라도 

906
01:09:57,300 --> 01:10:01,420
 계산할 수 그것은 꽤 분명이야이야 당신은 16 만 번호가있는 경우 

907
01:10:01,420 --> 01:10:05,880
 당신은 매우 빠른 그들과 경쟁하지만, 일단 (16)이 수도보다 더 얻을 수 있습니다 

908
01:10:05,880 --> 01:10:10,380
 열 여섯의 두 가지이기 때문에 실제로 숫자 정밀도에 대한 걱정 

909
01:10:10,380 --> 01:10:13,550
 다수의 큰되지는 더 이상 실제로 너무 많은 실수 당신입니다 

910
01:10:13,550 --> 01:10:20,360
 심지어 표현 그래서 몇 년 전에했던 것과이 논문이있다 할 수 있습니다 

911
01:10:20,359 --> 01:10:25,339
 일부 실험 낮은 정밀도 부동 소수점 그들은 발견 실제로 단지 

912
01:10:25,340 --> 01:10:28,710
 실험을 사용하여 그들이 실제로는 부동 소수점 고정 사용 

913
01:10:28,710 --> 01:10:34,819
 구현 및 그들이 발견 사실이 매우이와 

914
01:10:34,819 --> 01:10:38,659
 이러한 낮은 정밀 방법 네트워크의 오슬로의 순진 구현의 종류 

915
01:10:38,659 --> 01:10:43,689
 때문에이 낮은 정밀 Americare의 숫자에 아마 수렴 힘든 시간을했다 

916
01:10:43,689 --> 01:10:46,710
 종류의 곱셈의 여러 라운드를 통해 축적 문제와 

917
01:10:46,710 --> 01:10:50,989
 이것 저것 그러나 그들은 간단한 트릭이 실제로 확률이 아이디어 발견 

918
01:10:50,989 --> 01:10:54,559
 자신의 곱셈의 일부는 그렇게 것 때문에 모든 라운딩 자신의 

919
01:10:54,560 --> 01:10:55,200
 매개 변수 

920
01:10:55,199 --> 01:10:59,079
 정품 인증은 16 건에 저장되지만, 그들은 곱셈 그들은을 수행 할 때 

921
01:10:59,079 --> 01:11:03,269
 가입은 약간 높은 정밀도 부동 소수점 값으로 변환 

922
01:11:03,270 --> 01:11:07,570
 그들은 여전히​​ 낮은 위치까지 다시 라운드를 캐스팅하고 실제로 일을 

923
01:11:07,569 --> 01:11:11,789
 그 가장 가까운 숫자로 반올림되지 않은 확률 적 방법으로 반올림 

924
01:11:11,789 --> 01:11:16,479
 그러나 확률 적 방식에 따라 서로 다른 번호를 라운딩 

925
01:11:16,479 --> 01:11:17,549
 당신이 닫습니다 

926
01:11:17,550 --> 01:11:21,860
 더 나은 일을하고 그렇게 연습을하는 경향이 그들은 예를 들어 당신이있을 때 발견 

927
01:11:21,859 --> 01:11:26,710
 여섯 비트 고정 번호는 정수 두 개의 침대가 있었다 이러한 사용 

928
01:11:26,710 --> 01:11:31,170
 에 대한에 대한 부동 소수점 12, 14이 사이 서 

929
01:11:31,170 --> 01:11:35,239
 당신의이 아이디어를 사용할 때 항상 가장 가까운 반올림 것을 소수 부분 

930
01:11:35,239 --> 01:11:40,359
 수 이러한 네트워크 및 분기 만하는 이러한 확률 접지를 사용하는 경우 

931
01:11:40,359 --> 01:11:43,599
 실제로 이러한 네트워크는 아주 잘 수렴 얻을 수있는 기술 

932
01:11:43,600 --> 01:11:47,170
 심지어이 매우 낮은 밀도 부동 소수점 기술 낮은 정밀도 

933
01:11:47,170 --> 01:11:52,859
 부동 소수점 수 있지만 16 개의 비트가됩니다 대단한 문의 할 수 있습니다 

934
01:11:52,859 --> 01:11:59,089
 그러나 우리는 아래로있어 2015 년 다른 용지가보다하는 것이 더 낮은 갈 수 있습니다 

935
01:11:59,090 --> 01:12:04,560
 10 그래서 여기에 우리가 이미 가지고 있던 이전의 논문에서 의미하는 것으로 12 베팅 

936
01:12:04,560 --> 01:12:08,039
 이 직관 어쩌면 당신은 매우 낮은 정밀도를 사용하는 부동 소수점 

937
01:12:08,039 --> 01:12:11,359
 숫자는 실제로 네트워크의 일부 지역에서 더 정밀도를 사용할 필요가 

938
01:12:11,359 --> 01:12:15,909
 네트워크의 다른 부분에서 낮은 정밀이 논문에서 그들은했다 그래서 

939
01:12:15,909 --> 01:12:22,149
 (10)의 활성화에 이야기를 사용하여 멀리 얻을 수 10 비트 값을 비트 및 

940
01:12:22,149 --> 01:12:27,500
 12 베팅을 사용하여 컴퓨팅 그라데이션을하고 서서 그들은이 일을 가지고있는 

941
01:12:27,500 --> 01:12:34,800
 꽤 훌륭하지만 사람이 그 한계는 우리가 더 갈 수 있다고 생각 

942
01:12:34,800 --> 01:12:36,310
 예 

943
01:12:36,310 --> 01:12:44,180
 이 같은에서 실제로 있도록 용지는 지난 주에 실제로 있었다 

944
01:12:44,180 --> 01:12:49,200
 이전의 종이로 제작이는 내가 이것에 대해 놀랐다했다 미친이며, 

945
01:12:49,199 --> 01:12:53,539
 개념 네트워크의 모든 활성화 및 가중치 하나만​​을 사용하는 것이 듣는 

946
01:12:53,539 --> 01:12:58,819
 지금은 그렇지 계산하기 위해 꽤 빨리 둘 중 하나 또는 음을 내기 

947
01:12:58,819 --> 01:13:02,429
 심지어 정말 그냥 탐험 왜 같이 할 수 곱셈을해야하고 

948
01:13:02,430 --> 01:13:07,240
 꽤 멋진 것들을 곱하지만 트릭은 앞으로 패스를 그이다 

949
01:13:07,239 --> 01:13:11,199
 이 슈퍼 그래서 기울기 및 정품 인증 모두가 하나 또는 마이너스 하나 

950
01:13:11,199 --> 01:13:15,399
 슈퍼 슈퍼 신속하고 효율적인하지만 지금은 뒤로 패스에 물건 4 패스 

951
01:13:15,399 --> 01:13:20,179
 그들은 실제로 높은 정밀도와 다음이 이상을 사용하여 그라데이션을 계산 

952
01:13:20,180 --> 01:13:24,150
 정밀 그라디언트 실제로 이러한 단일 비트에 대한 업데이트를 확인하는 데 사용됩니다 

953
01:13:24,149 --> 01:13:28,059
 그것은 그래서 매개 변수는 실제로 정말 멋진 종이 그리고 내가 당신을 격려 것입니다 

954
01:13:28,060 --> 01:13:33,310
 그것을 확인하지만 피치는 그 당신이 감당할 수있는 훈련 시간이 될 수있다합니다 

955
01:13:33,310 --> 01:13:36,600
 어쩌면 부동 소수점 정밀도를 사용하지만 시험 시간은 당신이 원하는 마십시오 

956
01:13:36,600 --> 01:13:41,250
 나는 이것이 정말 생각 때문에 네트워크 슈퍼 슈퍼 빠른 모든 이진 될 수 있습니다 

957
01:13:41,250 --> 01:13:45,010
 나는 그것을 용지 뜻 정말 멋진 아이디어는 내가 2 주 전에 나온 

958
01:13:45,010 --> 01:13:50,460
 알고하지만 난 그것을에서 정리 해보 그래서 정말 멋진 일이 생각하지 않습니다 

959
01:13:50,460 --> 01:13:52,199
 구현 세부 사항 

960
01:13:52,199 --> 01:13:56,960
 전체 GPU는 CPU가 때때로 사람들이 사용보다 훨씬 더 빠르게 있다는 것입니다 

961
01:13:56,960 --> 01:14:00,739
 하나의 시스템에서 여러 GPU에 걸쳐 배포 배포 훈련은 예쁜 

962
01:14:00,739 --> 01:14:04,840
 일반 사용자의 구글과 사용 텐서 여러를 통해 배포 한 후 흐르는 경우 

963
01:14:04,840 --> 01:14:10,239
 노드는 어쩌면 더 일반적인 사이의 잠재적 인 병목을 알고 있어야한다 

964
01:14:10,239 --> 01:14:15,739
 책상에서 GPU 사이와 GPU 메모리 사이도 지불 CPU와 GPU 

965
01:14:15,739 --> 01:14:19,510
 부동 소수점 정밀도에 대한 관심은 가장 매력적인 일이 될하지 않을 수 있습니다 

966
01:14:19,510 --> 01:14:23,409
 하지만 실제로 나는 연습과 어쩌면 진에 큰 차이를 만드는 생각 

967
01:14:23,409 --> 01:14:28,639
 그래서 그래 그냥 정리해하는 너트 꽤 흥미로운 것 다음 큰 일이 될 것입니다 

968
01:14:28,640 --> 01:14:32,690
 모든 우리는 우리가 속임수로 날짜 확대 술 이야기 오늘 이야기 

969
01:14:32,689 --> 01:14:37,449
 당신이 작은 데이터 세트를 가지고 우리를 overfitting 방지 때 개선 

970
01:14:37,449 --> 01:14:40,859
 도움이 기존 모델에서 초기화하는 방법으로 전송 학습에 대해 이야기 

971
01:14:40,859 --> 01:14:44,399
 훈련과 당신의 도움으로 우리가에 대한 세부 사항을 많이 이야기 

972
01:14:44,399 --> 01:14:48,159
 회선 모두 효율적인 모델을 만들기 위해 그들을 결합하는 방법과 

973
01:14:48,159 --> 01:14:52,840
 나는 그 생각 때문에 우리는 모든 구현 세부 사항에 대해 이야기 

974
01:14:52,840 --> 01:14:57,319
 그것은 우리가 최대한 빨리 인쇄 한 모든 임의의 마지막 분 질문입니다입니다 

975
01:14:57,319 --> 01:15:02,840
 좋아, 그래서 우리가 몇 초 분, 우리 가운데 중간 고사를 마친 것 같아요 

